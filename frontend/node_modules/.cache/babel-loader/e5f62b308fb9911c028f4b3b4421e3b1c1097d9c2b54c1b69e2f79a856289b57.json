{"ast":null,"code":"var _jsxFileName = \"/home/bitcot/Documents/BitComm/frontend/src/context/VoiceContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\n/**\n * Voice Context\n *\n * Manages global voice state:\n * - WebSocket connection to backend\n * - Audio streaming (microphone → backend → speakers)\n * - UI updates from voice commands\n * - Transcripts for display\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VoiceContext = /*#__PURE__*/createContext(null);\n\n// WebSocket URL - adjust for production\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8005/ws';\nexport function VoiceProvider({\n  children\n}) {\n  _s();\n  const navigate = useNavigate();\n\n  // Connection state\n  const [isConnected, setIsConnected] = useState(false);\n  const [isListening, setIsListening] = useState(false);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Transcripts\n  const [userTranscript, setUserTranscript] = useState('');\n  const [assistantTranscript, setAssistantTranscript] = useState('');\n\n  // Last products (for reference in components)\n  const [lastProducts, setLastProducts] = useState([]);\n  const [lastFilters, setLastFilters] = useState({});\n\n  // Mute state for microphone\n  const [isMuted, setIsMuted] = useState(false);\n\n  // Flag to indicate voice-triggered update (prevents HTTP fetch race condition)\n  const voiceUpdateFlagRef = useRef(false);\n\n  // Callbacks for UI updates (set by Products page)\n  const onProductsUpdateRef = useRef(null);\n  const onFiltersUpdateRef = useRef(null);\n  const onProductDetailRef = useRef(null);\n  const onCompareRef = useRef(null);\n  const onAddToCartRef = useRef(null);\n\n  // WebSocket and Audio refs\n  const wsRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const mediaStreamRef = useRef(null);\n  const processorRef = useRef(null);\n  const playbackQueueRef = useRef([]);\n  const isPlayingRef = useRef(false);\n\n  /**\n   * Register callbacks for UI updates\n   */\n  const registerProductsCallback = useCallback(callback => {\n    onProductsUpdateRef.current = callback;\n  }, []);\n  const registerFiltersCallback = useCallback(callback => {\n    onFiltersUpdateRef.current = callback;\n  }, []);\n  const registerProductDetailCallback = useCallback(callback => {\n    onProductDetailRef.current = callback;\n  }, []);\n  const registerCompareCallback = useCallback(callback => {\n    onCompareRef.current = callback;\n  }, []);\n  const registerAddToCartCallback = useCallback(callback => {\n    onAddToCartRef.current = callback;\n  }, []);\n\n  /**\n   * Handle UI update events from backend\n   */\n  const handleUIUpdate = useCallback(event => {\n    console.log('UI Update received:', event);\n    const {\n      action,\n      navigate_to,\n      data,\n      filters\n    } = event;\n\n    // Handle navigation\n    if (navigate_to) {\n      navigate(navigate_to);\n    }\n\n    // Handle different actions\n    switch (action) {\n      case 'SHOW_PRODUCTS':\n        if (data !== null && data !== void 0 && data.products) {\n          setLastProducts(data.products);\n          setLastFilters(filters || {});\n\n          // Set flag to prevent HTTP fetch race condition\n          voiceUpdateFlagRef.current = true;\n\n          // Call registered callback to update Products page\n          if (onProductsUpdateRef.current) {\n            onProductsUpdateRef.current(data.products, data.total);\n          }\n          if (onFiltersUpdateRef.current && filters) {\n            onFiltersUpdateRef.current(filters);\n          }\n\n          // Clear flag after a short delay to allow React to batch updates\n          setTimeout(() => {\n            voiceUpdateFlagRef.current = false;\n          }, 500);\n        }\n        break;\n      case 'SHOW_PRODUCT_DETAILS':\n        // Open product detail modal\n        if (data !== null && data !== void 0 && data.product && onProductDetailRef.current) {\n          onProductDetailRef.current(data.product);\n        }\n        break;\n      case 'COMPARE_PRODUCTS':\n        // Open comparison modal\n        if (data !== null && data !== void 0 && data.products && onCompareRef.current) {\n          onCompareRef.current(data.products);\n        }\n        break;\n      case 'ADD_TO_CART':\n        // Add product to cart\n        if (data !== null && data !== void 0 && data.product && onAddToCartRef.current) {\n          onAddToCartRef.current(data.product);\n        }\n        break;\n      case 'NAVIGATE':\n        // Navigation already handled above\n        break;\n      default:\n        console.log('Unknown UI action:', action);\n    }\n  }, [navigate]);\n\n  /**\n   * Connect to WebSocket and start voice session\n   */\n  const startVoice = useCallback(async () => {\n    try {\n      // Request microphone permission\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: 24000,\n          channelCount: 1,\n          echoCancellation: true,\n          noiseSuppression: true\n        }\n      });\n      mediaStreamRef.current = stream;\n\n      // Create AudioContext for playback\n      audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: 24000\n      });\n\n      // Connect WebSocket\n      const ws = new WebSocket(WS_URL);\n      wsRef.current = ws;\n      ws.onopen = () => {\n        console.log('Voice WebSocket connected');\n        setIsConnected(true);\n        setIsListening(true);\n\n        // Start streaming audio\n        startAudioStreaming(stream);\n      };\n      ws.onmessage = async event => {\n        if (event.data instanceof Blob) {\n          // Audio data from AI - queue for playback\n          const arrayBuffer = await event.data.arrayBuffer();\n          playbackQueueRef.current.push(arrayBuffer);\n          setIsSpeaking(true);\n          playNextAudio();\n        } else {\n          // JSON event\n          try {\n            const data = JSON.parse(event.data);\n            handleWebSocketEvent(data);\n          } catch (e) {\n            console.error('Failed to parse WebSocket message:', e);\n          }\n        }\n      };\n      ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        setIsConnected(false);\n      };\n      ws.onclose = () => {\n        console.log('WebSocket closed');\n        setIsConnected(false);\n        setIsListening(false);\n        cleanup();\n      };\n    } catch (error) {\n      console.error('Failed to start voice:', error);\n      alert('Failed to access microphone. Please grant permission and try again.');\n    }\n  }, [handleUIUpdate]);\n\n  /**\n   * Handle WebSocket events\n   */\n  const handleWebSocketEvent = useCallback(data => {\n    const {\n      type\n    } = data;\n    switch (type) {\n      case 'user_transcript':\n        setUserTranscript(data.transcript);\n        setIsProcessing(true);\n        break;\n      case 'assistant_transcript':\n        setAssistantTranscript(data.transcript);\n        setIsProcessing(false);\n        break;\n      case 'ui_update':\n        handleUIUpdate(data);\n        break;\n      case 'clear_audio_queue':\n        // User interrupted - clear playback queue\n        playbackQueueRef.current = [];\n        setIsSpeaking(false);\n        break;\n      case 'error':\n        console.error('Voice error:', data.error);\n        break;\n      default:\n        // Ignore other events\n        break;\n    }\n  }, [handleUIUpdate]);\n\n  /**\n   * Start streaming microphone audio to backend\n   */\n  const startAudioStreaming = useCallback(stream => {\n    const audioContext = new AudioContext({\n      sampleRate: 24000\n    });\n    const source = audioContext.createMediaStreamSource(stream);\n\n    // Create ScriptProcessor for audio processing\n    const processor = audioContext.createScriptProcessor(4096, 1, 1);\n    processorRef.current = processor;\n    processor.onaudioprocess = e => {\n      var _wsRef$current;\n      if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n        const inputData = e.inputBuffer.getChannelData(0);\n\n        // Convert float32 to int16 PCM\n        const pcm16 = new Int16Array(inputData.length);\n        for (let i = 0; i < inputData.length; i++) {\n          const s = Math.max(-1, Math.min(1, inputData[i]));\n          pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n        }\n\n        // Send as binary\n        wsRef.current.send(pcm16.buffer);\n      }\n    };\n    source.connect(processor);\n    processor.connect(audioContext.destination);\n  }, []);\n\n  /**\n   * Play audio from queue\n   */\n  const playNextAudio = useCallback(async () => {\n    if (isPlayingRef.current || playbackQueueRef.current.length === 0) {\n      if (playbackQueueRef.current.length === 0) {\n        setIsSpeaking(false);\n      }\n      return;\n    }\n    isPlayingRef.current = true;\n    const audioData = playbackQueueRef.current.shift();\n    try {\n      const audioContext = audioContextRef.current;\n      if (!audioContext) return;\n\n      // Convert PCM16 to Float32\n      const int16Array = new Int16Array(audioData);\n      const float32Array = new Float32Array(int16Array.length);\n      for (let i = 0; i < int16Array.length; i++) {\n        float32Array[i] = int16Array[i] / 32768.0;\n      }\n\n      // Create audio buffer\n      const audioBuffer = audioContext.createBuffer(1, float32Array.length, 24000);\n      audioBuffer.getChannelData(0).set(float32Array);\n\n      // Play\n      const source = audioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(audioContext.destination);\n      source.onended = () => {\n        isPlayingRef.current = false;\n        playNextAudio();\n      };\n      source.start();\n    } catch (error) {\n      console.error('Audio playback error:', error);\n      isPlayingRef.current = false;\n      playNextAudio();\n    }\n  }, []);\n\n  /**\n   * Stop voice session\n   */\n  const stopVoice = useCallback(() => {\n    cleanup();\n    setIsConnected(false);\n    setIsListening(false);\n    setIsSpeaking(false);\n    setIsProcessing(false);\n    setIsMuted(false);\n  }, []);\n\n  /**\n   * Toggle voice session (for keyboard shortcut)\n   */\n  const toggleVoice = useCallback(async () => {\n    if (isConnected) {\n      stopVoice();\n    } else {\n      await startVoice();\n    }\n  }, [isConnected, startVoice, stopVoice]);\n\n  /**\n   * Toggle microphone mute\n   */\n  const toggleMute = useCallback(() => {\n    if (mediaStreamRef.current) {\n      const audioTrack = mediaStreamRef.current.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n        setIsMuted(!audioTrack.enabled);\n      }\n    }\n  }, []);\n\n  /**\n   * Check if voice update is in progress (to prevent HTTP fetch race condition)\n   */\n  const isVoiceUpdateInProgress = useCallback(() => {\n    return voiceUpdateFlagRef.current;\n  }, []);\n\n  /**\n   * Cleanup resources\n   */\n  const cleanup = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    if (mediaStreamRef.current) {\n      mediaStreamRef.current.getTracks().forEach(track => track.stop());\n      mediaStreamRef.current = null;\n    }\n    if (processorRef.current) {\n      processorRef.current.disconnect();\n      processorRef.current = null;\n    }\n    if (audioContextRef.current) {\n      audioContextRef.current.close();\n      audioContextRef.current = null;\n    }\n    playbackQueueRef.current = [];\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => cleanup();\n  }, [cleanup]);\n\n  /**\n   * Keyboard shortcuts:\n   * - Spacebar: Toggle voice session (start/stop)\n   * - Ctrl+M: Toggle microphone mute/unmute\n   */\n  useEffect(() => {\n    const handleKeyDown = e => {\n      // Ignore if user is typing in an input field\n      const activeElement = document.activeElement;\n      const isInputField = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable);\n\n      // Spacebar - Toggle voice session\n      if (e.code === 'Space' && !isInputField) {\n        e.preventDefault();\n        toggleVoice();\n      }\n\n      // Ctrl+M - Toggle mute\n      if (e.ctrlKey && e.code === 'KeyM') {\n        e.preventDefault();\n        if (isConnected) {\n          toggleMute();\n        }\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [toggleVoice, toggleMute, isConnected]);\n  const value = {\n    // State\n    isConnected,\n    isListening,\n    isProcessing,\n    isSpeaking,\n    isMuted,\n    userTranscript,\n    assistantTranscript,\n    lastProducts,\n    lastFilters,\n    // Actions\n    startVoice,\n    stopVoice,\n    toggleVoice,\n    toggleMute,\n    isVoiceUpdateInProgress,\n    registerProductsCallback,\n    registerFiltersCallback,\n    registerProductDetailCallback,\n    registerCompareCallback,\n    registerAddToCartCallback\n  };\n  return /*#__PURE__*/_jsxDEV(VoiceContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 466,\n    columnNumber: 5\n  }, this);\n}\n_s(VoiceProvider, \"J9N2iGyyNy+U6FOl6C3RhWanx6o=\", false, function () {\n  return [useNavigate];\n});\n_c = VoiceProvider;\nexport function useVoice() {\n  _s2();\n  const context = useContext(VoiceContext);\n  if (!context) {\n    throw new Error('useVoice must be used within a VoiceProvider');\n  }\n  return context;\n}\n_s2(useVoice, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"VoiceProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","useRef","useEffect","useNavigate","jsxDEV","_jsxDEV","VoiceContext","WS_URL","process","env","REACT_APP_WS_URL","VoiceProvider","children","_s","navigate","isConnected","setIsConnected","isListening","setIsListening","isProcessing","setIsProcessing","isSpeaking","setIsSpeaking","userTranscript","setUserTranscript","assistantTranscript","setAssistantTranscript","lastProducts","setLastProducts","lastFilters","setLastFilters","isMuted","setIsMuted","voiceUpdateFlagRef","onProductsUpdateRef","onFiltersUpdateRef","onProductDetailRef","onCompareRef","onAddToCartRef","wsRef","audioContextRef","mediaStreamRef","processorRef","playbackQueueRef","isPlayingRef","registerProductsCallback","callback","current","registerFiltersCallback","registerProductDetailCallback","registerCompareCallback","registerAddToCartCallback","handleUIUpdate","event","console","log","action","navigate_to","data","filters","products","total","setTimeout","product","startVoice","stream","navigator","mediaDevices","getUserMedia","audio","sampleRate","channelCount","echoCancellation","noiseSuppression","window","AudioContext","webkitAudioContext","ws","WebSocket","onopen","startAudioStreaming","onmessage","Blob","arrayBuffer","push","playNextAudio","JSON","parse","handleWebSocketEvent","e","error","onerror","onclose","cleanup","alert","type","transcript","audioContext","source","createMediaStreamSource","processor","createScriptProcessor","onaudioprocess","_wsRef$current","readyState","OPEN","inputData","inputBuffer","getChannelData","pcm16","Int16Array","length","i","s","Math","max","min","send","buffer","connect","destination","audioData","shift","int16Array","float32Array","Float32Array","audioBuffer","createBuffer","set","createBufferSource","onended","start","stopVoice","toggleVoice","toggleMute","audioTrack","getAudioTracks","enabled","isVoiceUpdateInProgress","close","getTracks","forEach","track","stop","disconnect","handleKeyDown","activeElement","document","isInputField","tagName","isContentEditable","code","preventDefault","ctrlKey","addEventListener","removeEventListener","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useVoice","_s2","context","Error","$RefreshReg$"],"sources":["/home/bitcot/Documents/BitComm/frontend/src/context/VoiceContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\n/**\n * Voice Context\n *\n * Manages global voice state:\n * - WebSocket connection to backend\n * - Audio streaming (microphone → backend → speakers)\n * - UI updates from voice commands\n * - Transcripts for display\n */\n\nconst VoiceContext = createContext(null);\n\n// WebSocket URL - adjust for production\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8005/ws';\n\nexport function VoiceProvider({ children }) {\n  const navigate = useNavigate();\n\n  // Connection state\n  const [isConnected, setIsConnected] = useState(false);\n  const [isListening, setIsListening] = useState(false);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n\n  // Transcripts\n  const [userTranscript, setUserTranscript] = useState('');\n  const [assistantTranscript, setAssistantTranscript] = useState('');\n\n  // Last products (for reference in components)\n  const [lastProducts, setLastProducts] = useState([]);\n  const [lastFilters, setLastFilters] = useState({});\n\n  // Mute state for microphone\n  const [isMuted, setIsMuted] = useState(false);\n\n  // Flag to indicate voice-triggered update (prevents HTTP fetch race condition)\n  const voiceUpdateFlagRef = useRef(false);\n\n  // Callbacks for UI updates (set by Products page)\n  const onProductsUpdateRef = useRef(null);\n  const onFiltersUpdateRef = useRef(null);\n  const onProductDetailRef = useRef(null);\n  const onCompareRef = useRef(null);\n  const onAddToCartRef = useRef(null);\n\n  // WebSocket and Audio refs\n  const wsRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const mediaStreamRef = useRef(null);\n  const processorRef = useRef(null);\n  const playbackQueueRef = useRef([]);\n  const isPlayingRef = useRef(false);\n\n  /**\n   * Register callbacks for UI updates\n   */\n  const registerProductsCallback = useCallback((callback) => {\n    onProductsUpdateRef.current = callback;\n  }, []);\n\n  const registerFiltersCallback = useCallback((callback) => {\n    onFiltersUpdateRef.current = callback;\n  }, []);\n\n  const registerProductDetailCallback = useCallback((callback) => {\n    onProductDetailRef.current = callback;\n  }, []);\n\n  const registerCompareCallback = useCallback((callback) => {\n    onCompareRef.current = callback;\n  }, []);\n\n  const registerAddToCartCallback = useCallback((callback) => {\n    onAddToCartRef.current = callback;\n  }, []);\n\n  /**\n   * Handle UI update events from backend\n   */\n  const handleUIUpdate = useCallback((event) => {\n    console.log('UI Update received:', event);\n\n    const { action, navigate_to, data, filters } = event;\n\n    // Handle navigation\n    if (navigate_to) {\n      navigate(navigate_to);\n    }\n\n    // Handle different actions\n    switch (action) {\n      case 'SHOW_PRODUCTS':\n        if (data?.products) {\n          setLastProducts(data.products);\n          setLastFilters(filters || {});\n\n          // Set flag to prevent HTTP fetch race condition\n          voiceUpdateFlagRef.current = true;\n\n          // Call registered callback to update Products page\n          if (onProductsUpdateRef.current) {\n            onProductsUpdateRef.current(data.products, data.total);\n          }\n          if (onFiltersUpdateRef.current && filters) {\n            onFiltersUpdateRef.current(filters);\n          }\n\n          // Clear flag after a short delay to allow React to batch updates\n          setTimeout(() => {\n            voiceUpdateFlagRef.current = false;\n          }, 500);\n        }\n        break;\n\n      case 'SHOW_PRODUCT_DETAILS':\n        // Open product detail modal\n        if (data?.product && onProductDetailRef.current) {\n          onProductDetailRef.current(data.product);\n        }\n        break;\n\n      case 'COMPARE_PRODUCTS':\n        // Open comparison modal\n        if (data?.products && onCompareRef.current) {\n          onCompareRef.current(data.products);\n        }\n        break;\n\n      case 'ADD_TO_CART':\n        // Add product to cart\n        if (data?.product && onAddToCartRef.current) {\n          onAddToCartRef.current(data.product);\n        }\n        break;\n\n      case 'NAVIGATE':\n        // Navigation already handled above\n        break;\n\n      default:\n        console.log('Unknown UI action:', action);\n    }\n  }, [navigate]);\n\n  /**\n   * Connect to WebSocket and start voice session\n   */\n  const startVoice = useCallback(async () => {\n    try {\n      // Request microphone permission\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: 24000,\n          channelCount: 1,\n          echoCancellation: true,\n          noiseSuppression: true,\n        }\n      });\n      mediaStreamRef.current = stream;\n\n      // Create AudioContext for playback\n      audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: 24000\n      });\n\n      // Connect WebSocket\n      const ws = new WebSocket(WS_URL);\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        console.log('Voice WebSocket connected');\n        setIsConnected(true);\n        setIsListening(true);\n\n        // Start streaming audio\n        startAudioStreaming(stream);\n      };\n\n      ws.onmessage = async (event) => {\n        if (event.data instanceof Blob) {\n          // Audio data from AI - queue for playback\n          const arrayBuffer = await event.data.arrayBuffer();\n          playbackQueueRef.current.push(arrayBuffer);\n          setIsSpeaking(true);\n          playNextAudio();\n        } else {\n          // JSON event\n          try {\n            const data = JSON.parse(event.data);\n            handleWebSocketEvent(data);\n          } catch (e) {\n            console.error('Failed to parse WebSocket message:', e);\n          }\n        }\n      };\n\n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        setIsConnected(false);\n      };\n\n      ws.onclose = () => {\n        console.log('WebSocket closed');\n        setIsConnected(false);\n        setIsListening(false);\n        cleanup();\n      };\n\n    } catch (error) {\n      console.error('Failed to start voice:', error);\n      alert('Failed to access microphone. Please grant permission and try again.');\n    }\n  }, [handleUIUpdate]);\n\n  /**\n   * Handle WebSocket events\n   */\n  const handleWebSocketEvent = useCallback((data) => {\n    const { type } = data;\n\n    switch (type) {\n      case 'user_transcript':\n        setUserTranscript(data.transcript);\n        setIsProcessing(true);\n        break;\n\n      case 'assistant_transcript':\n        setAssistantTranscript(data.transcript);\n        setIsProcessing(false);\n        break;\n\n      case 'ui_update':\n        handleUIUpdate(data);\n        break;\n\n      case 'clear_audio_queue':\n        // User interrupted - clear playback queue\n        playbackQueueRef.current = [];\n        setIsSpeaking(false);\n        break;\n\n      case 'error':\n        console.error('Voice error:', data.error);\n        break;\n\n      default:\n        // Ignore other events\n        break;\n    }\n  }, [handleUIUpdate]);\n\n  /**\n   * Start streaming microphone audio to backend\n   */\n  const startAudioStreaming = useCallback((stream) => {\n    const audioContext = new AudioContext({ sampleRate: 24000 });\n    const source = audioContext.createMediaStreamSource(stream);\n\n    // Create ScriptProcessor for audio processing\n    const processor = audioContext.createScriptProcessor(4096, 1, 1);\n    processorRef.current = processor;\n\n    processor.onaudioprocess = (e) => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        const inputData = e.inputBuffer.getChannelData(0);\n\n        // Convert float32 to int16 PCM\n        const pcm16 = new Int16Array(inputData.length);\n        for (let i = 0; i < inputData.length; i++) {\n          const s = Math.max(-1, Math.min(1, inputData[i]));\n          pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n        }\n\n        // Send as binary\n        wsRef.current.send(pcm16.buffer);\n      }\n    };\n\n    source.connect(processor);\n    processor.connect(audioContext.destination);\n  }, []);\n\n  /**\n   * Play audio from queue\n   */\n  const playNextAudio = useCallback(async () => {\n    if (isPlayingRef.current || playbackQueueRef.current.length === 0) {\n      if (playbackQueueRef.current.length === 0) {\n        setIsSpeaking(false);\n      }\n      return;\n    }\n\n    isPlayingRef.current = true;\n    const audioData = playbackQueueRef.current.shift();\n\n    try {\n      const audioContext = audioContextRef.current;\n      if (!audioContext) return;\n\n      // Convert PCM16 to Float32\n      const int16Array = new Int16Array(audioData);\n      const float32Array = new Float32Array(int16Array.length);\n      for (let i = 0; i < int16Array.length; i++) {\n        float32Array[i] = int16Array[i] / 32768.0;\n      }\n\n      // Create audio buffer\n      const audioBuffer = audioContext.createBuffer(1, float32Array.length, 24000);\n      audioBuffer.getChannelData(0).set(float32Array);\n\n      // Play\n      const source = audioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(audioContext.destination);\n      source.onended = () => {\n        isPlayingRef.current = false;\n        playNextAudio();\n      };\n      source.start();\n    } catch (error) {\n      console.error('Audio playback error:', error);\n      isPlayingRef.current = false;\n      playNextAudio();\n    }\n  }, []);\n\n  /**\n   * Stop voice session\n   */\n  const stopVoice = useCallback(() => {\n    cleanup();\n    setIsConnected(false);\n    setIsListening(false);\n    setIsSpeaking(false);\n    setIsProcessing(false);\n    setIsMuted(false);\n  }, []);\n\n  /**\n   * Toggle voice session (for keyboard shortcut)\n   */\n  const toggleVoice = useCallback(async () => {\n    if (isConnected) {\n      stopVoice();\n    } else {\n      await startVoice();\n    }\n  }, [isConnected, startVoice, stopVoice]);\n\n  /**\n   * Toggle microphone mute\n   */\n  const toggleMute = useCallback(() => {\n    if (mediaStreamRef.current) {\n      const audioTrack = mediaStreamRef.current.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n        setIsMuted(!audioTrack.enabled);\n      }\n    }\n  }, []);\n\n  /**\n   * Check if voice update is in progress (to prevent HTTP fetch race condition)\n   */\n  const isVoiceUpdateInProgress = useCallback(() => {\n    return voiceUpdateFlagRef.current;\n  }, []);\n\n  /**\n   * Cleanup resources\n   */\n  const cleanup = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n\n    if (mediaStreamRef.current) {\n      mediaStreamRef.current.getTracks().forEach(track => track.stop());\n      mediaStreamRef.current = null;\n    }\n\n    if (processorRef.current) {\n      processorRef.current.disconnect();\n      processorRef.current = null;\n    }\n\n    if (audioContextRef.current) {\n      audioContextRef.current.close();\n      audioContextRef.current = null;\n    }\n\n    playbackQueueRef.current = [];\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => cleanup();\n  }, [cleanup]);\n\n  /**\n   * Keyboard shortcuts:\n   * - Spacebar: Toggle voice session (start/stop)\n   * - Ctrl+M: Toggle microphone mute/unmute\n   */\n  useEffect(() => {\n    const handleKeyDown = (e) => {\n      // Ignore if user is typing in an input field\n      const activeElement = document.activeElement;\n      const isInputField = activeElement && (\n        activeElement.tagName === 'INPUT' ||\n        activeElement.tagName === 'TEXTAREA' ||\n        activeElement.isContentEditable\n      );\n\n      // Spacebar - Toggle voice session\n      if (e.code === 'Space' && !isInputField) {\n        e.preventDefault();\n        toggleVoice();\n      }\n\n      // Ctrl+M - Toggle mute\n      if (e.ctrlKey && e.code === 'KeyM') {\n        e.preventDefault();\n        if (isConnected) {\n          toggleMute();\n        }\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [toggleVoice, toggleMute, isConnected]);\n\n  const value = {\n    // State\n    isConnected,\n    isListening,\n    isProcessing,\n    isSpeaking,\n    isMuted,\n    userTranscript,\n    assistantTranscript,\n    lastProducts,\n    lastFilters,\n\n    // Actions\n    startVoice,\n    stopVoice,\n    toggleVoice,\n    toggleMute,\n    isVoiceUpdateInProgress,\n    registerProductsCallback,\n    registerFiltersCallback,\n    registerProductDetailCallback,\n    registerCompareCallback,\n    registerAddToCartCallback,\n  };\n\n  return (\n    <VoiceContext.Provider value={value}>\n      {children}\n    </VoiceContext.Provider>\n  );\n}\n\nexport function useVoice() {\n  const context = useContext(VoiceContext);\n  if (!context) {\n    throw new Error('useVoice must be used within a VoiceProvider');\n  }\n  return context;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}