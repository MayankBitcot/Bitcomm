import asyncio
import os
import sys
import unittest
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch

from ragent.guardrails.app import GuardrailManager
from ragent.guardrails.custom_guardrails import (
    EntitySpan,
    MaskingResult,
    PHIConfig,
    PIIConfig,
    SensitiveInfoConfig,
    SensitiveInfoMasker,
    create_config_builder,
    create_masker,
)
from ragent.guardrails.default_openai_guardrails import GuardrailProcessor

# Add the parent directory to the Python path


sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))


class TestGuardrailManager(unittest.TestCase):
    """Test cases for the GuardrailManager class."""

    def setUp(self):
        """Set up test environment before each test."""
        self.test_text = (
            "My email is john.doe@example.com and my phone number is 123-456-7890."
        )
        self.test_config_file = os.path.join(
            os.path.dirname(__file__), "test_config.json"
        )

    def test_initialization_openai_guardrails(self):
        """Test initialization with OpenAI guardrails."""
        with patch(
            "ragent.guardrails.default_openai_guardrails.GuardrailProcessor"
        ) as mock_processor:
            manager = GuardrailManager("openai_guardrails", self.test_config_file)

            self.assertEqual(manager.guardrail_type, "openai_guardrails")
            self.assertEqual(manager.config_file, self.test_config_file)
            self.assertEqual(manager.model, "gpt-4o")
            self.assertEqual(manager.temperature, 0.0)
            mock_processor.assert_called_once_with(self.test_config_file, "gpt-4o", 0.0)

    def test_initialization_custom_guardrails(self):
        """Test initialization with custom guardrails."""
        with patch("ragent.guardrails.app.create_masker") as mock_create_masker:
            manager = GuardrailManager("custom_guardrails")

            self.assertEqual(manager.guardrail_type, "custom_guardrails")
            self.assertEqual(manager.model, "gpt-4o")
            self.assertEqual(manager.temperature, 0.0)
            mock_create_masker.assert_called_once_with(model="gpt-4o", temperature=0.0)

    def test_initialization_custom_model_temperature(self):
        """Test initialization with custom model and temperature."""
        with patch(
            "ragent.guardrails.default_openai_guardrails.GuardrailProcessor"
        ) as mock_processor:
            manager = GuardrailManager(
                "openai_guardrails",
                self.test_config_file,
                model="gpt-4o-mini",
                temperature=0.1,
            )

            self.assertEqual(manager.model, "gpt-4o-mini")
            self.assertEqual(manager.temperature, 0.1)
            mock_processor.assert_called_once_with(
                self.test_config_file, "gpt-4o-mini", 0.1
            )

    def test_invalid_guardrail_type(self):
        """Test initialization with invalid guardrail type."""
        with self.assertRaises(ValueError):
            GuardrailManager("invalid_type")

    @patch("ragent.guardrails.default_openai_guardrails.GuardrailProcessor")
    def test_process_text_openai_guardrails(self, mock_processor_class):
        """Test processing text with OpenAI guardrails."""
        # Mock the processor instance
        mock_processor = AsyncMock()
        mock_processor.process_text.return_value = {"result": "mocked_openai_result"}
        mock_processor_class.return_value = mock_processor

        manager = GuardrailManager("openai_guardrails", self.test_config_file)
        result = asyncio.run(manager.process_text(self.test_text))

        self.assertEqual(result["type"], "openai_guardrails")
        self.assertEqual(result["result"], {"result": "mocked_openai_result"})
        self.assertTrue(result["success"])
        mock_processor.process_text.assert_called_once_with(self.test_text, None)

    @patch("ragent.guardrails.app.create_masker")
    def test_process_text_custom_guardrails(self, mock_create_masker):
        """Test processing text with custom guardrails."""
        # Mock the masker instance
        mock_masker = MagicMock()
        mock_result = MaskingResult(
            query="masked text",
            entities=["email", "phone"],
            spans=[EntitySpan(entity="email", start_word=1, end_word=2)],
            strategy_used="UNIFIED",
            original_text=self.test_text,
        )
        mock_masker.mask_sensitive_data.return_value = mock_result
        mock_create_masker.return_value = mock_masker

        manager = GuardrailManager("custom_guardrails")
        result = asyncio.run(manager.process_text(self.test_text))

        self.assertEqual(result["type"], "custom_guardrails")
        self.assertEqual(result["result"], mock_result)
        self.assertTrue(result["success"])
        mock_masker.mask_sensitive_data.assert_called_once_with(self.test_text)

    @patch("ragent.guardrails.app.create_masker")
    def test_process_text_custom_guardrails_with_config(self, mock_create_masker):
        """Test processing text with custom guardrails and custom configuration."""
        # Mock the masker instance
        mock_masker = MagicMock()
        mock_result = MaskingResult(
            query="masked text with config",
            entities=["email"],
            spans=[],
            strategy_used="UNIFIED",
            original_text=self.test_text,
        )
        mock_masker.mask_sensitive_data.return_value = mock_result
        mock_create_masker.return_value = mock_masker

        manager = GuardrailManager("custom_guardrails")
        result = asyncio.run(
            manager.process_text(
                self.test_text,
                enable_pii=True,
                enable_phi=False,
                custom_entities=["employee IDs"],
            )
        )

        self.assertEqual(result["type"], "custom_guardrails")
        self.assertEqual(result["result"], mock_result)
        self.assertTrue(result["success"])
        # create_masker is called twice: once during init, once with custom config
        self.assertEqual(mock_create_masker.call_count, 2)

    @patch("ragent.guardrails.default_openai_guardrails.GuardrailProcessor")
    def test_process_text_openai_guardrails_error(self, mock_processor_class):
        """Test processing text with OpenAI guardrails when error occurs."""
        # Mock the processor instance to raise an exception
        mock_processor = AsyncMock()
        mock_processor.process_text.side_effect = Exception("Test error")
        mock_processor_class.return_value = mock_processor

        manager = GuardrailManager("openai_guardrails", self.test_config_file)
        result = asyncio.run(manager.process_text(self.test_text))

        self.assertEqual(result["type"], "openai_guardrails")
        self.assertIsNone(result["result"])
        self.assertFalse(result["success"])
        self.assertEqual(result["error"], "Test error")

    def test_switch_guardrail_type_openai(self):
        """Test switching to OpenAI guardrails."""
        with patch(
            "ragent.guardrails.default_openai_guardrails.GuardrailProcessor"
        ) as mock_processor, patch(
            "ragent.guardrails.app.create_masker"
        ) as mock_create_masker:
            manager = GuardrailManager("custom_guardrails")
            manager.switch_guardrail_type("openai_guardrails", self.test_config_file)

            self.assertEqual(manager.guardrail_type, "openai_guardrails")
            mock_processor.assert_called_once_with(self.test_config_file, "gpt-4o", 0.0)

    def test_switch_guardrail_type_custom(self):
        """Test switching to custom guardrails."""
        with patch(
            "ragent.guardrails.default_openai_guardrails.GuardrailProcessor"
        ) as mock_processor, patch(
            "ragent.guardrails.app.create_masker"
        ) as mock_create_masker:
            manager = GuardrailManager("openai_guardrails", self.test_config_file)
            manager.switch_guardrail_type("custom_guardrails")

            self.assertEqual(manager.guardrail_type, "custom_guardrails")
            mock_create_masker.assert_called_once_with(model="gpt-4o", temperature=0.0)

    def test_switch_guardrail_type_with_custom_model_temperature(self):
        """Test switching guardrail type with custom model and temperature."""
        with patch(
            "ragent.guardrails.default_openai_guardrails.GuardrailProcessor"
        ) as mock_processor, patch(
            "ragent.guardrails.app.create_masker"
        ) as mock_create_masker:
            manager = GuardrailManager("custom_guardrails")
            manager.switch_guardrail_type(
                "openai_guardrails",
                self.test_config_file,
                model="gpt-4o-mini",
                temperature=0.1,
            )

            self.assertEqual(manager.model, "gpt-4o-mini")
            self.assertEqual(manager.temperature, 0.1)
            mock_processor.assert_called_once_with(
                self.test_config_file, "gpt-4o-mini", 0.1
            )


class TestSensitiveInfoMasker(unittest.TestCase):
    """Test cases for the SensitiveInfoMasker class."""

    def setUp(self):
        """Set up test environment before each test."""
        self.test_config = SensitiveInfoConfig()
        self.test_text = (
            "John Smith, john@example.com, 555-123-4567, has cancer, MRN 12345"
        )

    @patch("ragent.guardrails.custom_guardrails.ChatOpenAI")
    def test_initialization_default(self, mock_chat_openai):
        """Test initialization with default parameters."""
        masker = SensitiveInfoMasker(self.test_config)
        mock_chat_openai.assert_called_once_with(model="gpt-4o", temperature=0.0)

    @patch("ragent.guardrails.custom_guardrails.ChatOpenAI")
    def test_initialization_custom_model_temperature(self, mock_chat_openai):
        """Test initialization with custom model and temperature."""
        masker = SensitiveInfoMasker(
            self.test_config, model="gpt-4o-mini", temperature=0.1
        )
        mock_chat_openai.assert_called_once_with(model="gpt-4o-mini", temperature=0.1)

    @patch("ragent.guardrails.custom_guardrails.ChatOpenAI")
    def test_mask_sensitive_data_success(self, mock_chat_openai):
        """Test successful masking of sensitive data."""
        # Mock the LLM response
        mock_llm = MagicMock()
        mock_structured_llm = MagicMock()
        mock_result = MaskingResult(
            query="**** ****, ******************, ************, has ******, *********",
            entities=["name", "email", "phone", "medical_condition", "medical_record"],
            spans=[
                EntitySpan(entity="name", start_word=1, end_word=2),
                EntitySpan(entity="email", start_word=3, end_word=3),
                EntitySpan(entity="phone", start_word=4, end_word=4),
                EntitySpan(entity="medical_condition", start_word=6, end_word=6),
                EntitySpan(entity="medical_record", start_word=7, end_word=7),
            ],
            strategy_used="UNIFIED",
            original_text=self.test_text,
        )
        mock_structured_llm.invoke.return_value = mock_result
        mock_llm.with_structured_output.return_value = mock_structured_llm
        mock_chat_openai.return_value = mock_llm

        masker = SensitiveInfoMasker(self.test_config)
        result = masker.mask_sensitive_data(self.test_text)

        self.assertEqual(result.query, mock_result.query)
        self.assertEqual(result.entities, mock_result.entities)
        self.assertEqual(result.spans, mock_result.spans)
        self.assertEqual(result.strategy_used, "UNIFIED")
        self.assertEqual(result.original_text, self.test_text)

    @patch("ragent.guardrails.custom_guardrails.ChatOpenAI")
    def test_mask_sensitive_data_error(self, mock_chat_openai):
        """Test error handling in masking sensitive data."""
        # Mock the LLM to raise an exception
        mock_llm = MagicMock()
        mock_structured_llm = MagicMock()
        mock_structured_llm.invoke.side_effect = Exception("LLM error")
        mock_llm.with_structured_output.return_value = mock_structured_llm
        mock_chat_openai.return_value = mock_llm

        masker = SensitiveInfoMasker(self.test_config)
        result = masker.mask_sensitive_data(self.test_text)

        self.assertEqual(result.query, self.test_text)
        self.assertEqual(result.original_text, self.test_text)
        self.assertEqual(result.strategy_used, "UNIFIED")

    @patch("ragent.guardrails.custom_guardrails.ChatOpenAI")
    def test_mask_sensitive_data_no_entities(self, mock_chat_openai):
        """Test masking when no entities are configured."""
        # Create config with no entities enabled
        config = SensitiveInfoConfig(
            enable_pii=False, enable_phi=False, custom_entities=[]
        )

        masker = SensitiveInfoMasker(config)
        result = masker.mask_sensitive_data(self.test_text)

        self.assertEqual(result.query, self.test_text)
        self.assertEqual(result.original_text, self.test_text)
        self.assertEqual(result.strategy_used, "UNIFIED")


class TestGuardrailProcessor(unittest.TestCase):
    """Test cases for the GuardrailProcessor class."""

    def setUp(self):
        """Set up test environment before each test."""
        self.test_text = (
            "My email is john.doe@example.com and my phone number is 123-456-7890."
        )
        self.test_config_file = os.path.join(
            os.path.dirname(__file__), "test_config.json"
        )

    @patch("ragent.guardrails.default_openai_guardrails.GuardrailsAsyncOpenAI")
    def test_initialization_default(self, mock_guardrails):
        """Test initialization with default parameters."""
        processor = GuardrailProcessor(self.test_config_file)

        self.assertEqual(processor.config_file, self.test_config_file)
        self.assertEqual(processor.model, "gpt-4o")
        self.assertEqual(processor.temperature, 0.0)
        mock_guardrails.assert_called_once_with(config=Path(self.test_config_file))

    @patch("ragent.guardrails.default_openai_guardrails.GuardrailsAsyncOpenAI")
    def test_initialization_custom_model_temperature(self, mock_guardrails):
        """Test initialization with custom model and temperature."""
        processor = GuardrailProcessor(
            self.test_config_file, model="gpt-4o-mini", temperature=0.1
        )

        self.assertEqual(processor.model, "gpt-4o-mini")
        self.assertEqual(processor.temperature, 0.1)

    @patch("ragent.guardrails.default_openai_guardrails.GuardrailsAsyncOpenAI")
    def test_process_text_success(self, mock_guardrails_class):
        """Test successful processing of text."""
        # Mock the client and response
        mock_client = AsyncMock()
        mock_response = MagicMock()
        mock_response.llm_response.output_text = "Processed text"
        mock_response.guardrail_results = None
        mock_client.responses.create.return_value = mock_response
        mock_guardrails_class.return_value = mock_client

        processor = GuardrailProcessor(self.test_config_file)
        result = asyncio.run(processor.process_text(self.test_text))

        self.assertEqual(result, mock_response)
        mock_client.responses.create.assert_called_once_with(
            model="gpt-4o",
            input=self.test_text,
            instructions="You are a helpful assistant, your role is to return exact user input as received from the user. You are strictly prohibited from generating response or altering user query",
        )

    @patch("ragent.guardrails.default_openai_guardrails.GuardrailsAsyncOpenAI")
    def test_process_text_with_guardrail_results(self, mock_guardrails_class):
        """Test processing text with guardrail results."""
        # Mock the client and response with guardrail results
        mock_client = AsyncMock()
        mock_response = MagicMock()
        mock_response.llm_response.output_text = "Processed text"
        mock_response.guardrail_results = MagicMock()
        mock_response.guardrail_results.output = [MagicMock()]
        mock_response.guardrail_results.output[0].info = {"checked_text": "Masked text"}
        mock_client.responses.create.return_value = mock_response
        mock_guardrails_class.return_value = mock_client

        processor = GuardrailProcessor(self.test_config_file)
        result = asyncio.run(processor.process_text(self.test_text))

        self.assertEqual(result, mock_response)

    @patch("ragent.guardrails.default_openai_guardrails.GuardrailsAsyncOpenAI")
    def test_process_text_guardrail_triggered(self, mock_guardrails_class):
        """Test processing text when guardrail is triggered."""
        from ragent.guardrails.default_openai_guardrails import (
            GuardrailTripwireTriggered,
        )

        # Mock the client to raise GuardrailTripwireTriggered
        mock_client = AsyncMock()
        mock_guardrail_result = MagicMock()
        mock_guardrail_result.info = {"triggered": True, "reason": "Test trigger"}
        mock_exception = GuardrailTripwireTriggered("Test error")
        mock_exception.guardrail_result = mock_guardrail_result
        mock_client.responses.create.side_effect = mock_exception
        mock_guardrails_class.return_value = mock_client

        processor = GuardrailProcessor(self.test_config_file)
        result = asyncio.run(processor.process_text(self.test_text))

        self.assertEqual(result, mock_guardrail_result.info)

    @patch("ragent.guardrails.default_openai_guardrails.GuardrailsAsyncOpenAI")
    def test_process_text_general_error(self, mock_guardrails_class):
        """Test processing text when general error occurs."""
        # Mock the client to raise a general exception
        mock_client = AsyncMock()
        mock_client.responses.create.side_effect = Exception("General error")
        mock_guardrails_class.return_value = mock_client

        processor = GuardrailProcessor(self.test_config_file)
        result = asyncio.run(processor.process_text(self.test_text))

        self.assertEqual(result["error"], "An error occurred: General error")


class TestFactoryFunctions(unittest.TestCase):
    """Test cases for factory functions."""

    @patch("ragent.guardrails.custom_guardrails.SensitiveInfoMasker")
    def test_create_masker_default(self, mock_masker_class):
        """Test create_masker with default parameters."""
        mock_masker = MagicMock()
        mock_masker_class.return_value = mock_masker

        result = create_masker()

        mock_masker_class.assert_called_once_with(SensitiveInfoConfig(), "gpt-4o", 0.0)
        self.assertEqual(result, mock_masker)

    @patch("ragent.guardrails.custom_guardrails.SensitiveInfoMasker")
    def test_create_masker_custom(self, mock_masker_class):
        """Test create_masker with custom parameters."""
        mock_masker = MagicMock()
        mock_masker_class.return_value = mock_masker
        config = SensitiveInfoConfig(enable_pii=False)

        result = create_masker(config, model="gpt-4o-mini", temperature=0.1)

        mock_masker_class.assert_called_once_with(config, "gpt-4o-mini", 0.1)
        self.assertEqual(result, mock_masker)

    def test_create_config_builder(self):
        """Test create_config_builder function."""
        from ragent.guardrails.custom_guardrails import MaskingConfigBuilder

        builder = create_config_builder()

        self.assertIsInstance(builder, MaskingConfigBuilder)


class TestConfigurationBuilder(unittest.TestCase):
    """Test cases for MaskingConfigBuilder."""

    def test_initialization(self):
        """Test builder initialization."""
        builder = create_config_builder()

        self.assertIsInstance(builder.config, SensitiveInfoConfig)

    def test_enable_pii(self):
        """Test enabling/disabling PII."""
        builder = create_config_builder()
        result = builder.enable_pii(False)

        self.assertEqual(builder.config.enable_pii, False)
        self.assertEqual(result, builder)  # Should return self for chaining

    def test_enable_phi(self):
        """Test enabling/disabling PHI."""
        builder = create_config_builder()
        result = builder.enable_phi(False)

        self.assertEqual(builder.config.enable_phi, False)
        self.assertEqual(result, builder)  # Should return self for chaining

    def test_add_custom_entities(self):
        """Test adding custom entities."""
        builder = create_config_builder()
        entities = ["employee IDs", "company names"]
        result = builder.add_custom_entities(entities)

        self.assertEqual(builder.config.custom_entities, entities)
        self.assertEqual(result, builder)  # Should return self for chaining

    def test_configure_pii(self):
        """Test configuring PII settings."""
        builder = create_config_builder()
        result = builder.configure_pii(emails=False, phones=True)

        self.assertEqual(builder.config.pii_config.emails, False)
        self.assertEqual(builder.config.pii_config.phones, True)
        self.assertEqual(result, builder)  # Should return self for chaining

    def test_configure_phi(self):
        """Test configuring PHI settings."""
        builder = create_config_builder()
        result = builder.configure_phi(medical_conditions=False, medical_records=True)

        self.assertEqual(builder.config.phi_config.medical_conditions, False)
        self.assertEqual(builder.config.phi_config.medical_records, True)
        self.assertEqual(result, builder)  # Should return self for chaining

    def test_build(self):
        """Test building the configuration."""
        builder = create_config_builder()
        config = builder.build()

        self.assertIsInstance(config, SensitiveInfoConfig)


class TestDataModels(unittest.TestCase):
    """Test cases for data models."""

    def test_entity_span(self):
        """Test EntitySpan model."""
        span = EntitySpan(entity="email", start_word=1, end_word=2)

        self.assertEqual(span.entity, "email")
        self.assertEqual(span.start_word, 1)
        self.assertEqual(span.end_word, 2)

    def test_masking_result(self):
        """Test MaskingResult model."""
        spans = [EntitySpan(entity="email", start_word=1, end_word=2)]
        result = MaskingResult(
            query="masked text",
            entities=["email"],
            spans=spans,
            strategy_used="UNIFIED",
            original_text="original text",
        )

        self.assertEqual(result.query, "masked text")
        self.assertEqual(result.entities, ["email"])
        self.assertEqual(result.spans, spans)
        self.assertEqual(result.strategy_used, "UNIFIED")
        self.assertEqual(result.original_text, "original text")

    def test_pii_config(self):
        """Test PIIConfig model."""
        config = PIIConfig(emails=False, phones=True)

        self.assertEqual(config.emails, False)
        self.assertEqual(config.phones, True)
        self.assertEqual(config.name, True)  # Default value

    def test_phi_config(self):
        """Test PHIConfig model."""
        config = PHIConfig(medical_conditions=False, medical_records=True)

        self.assertEqual(config.medical_conditions, False)
        self.assertEqual(config.medical_records, True)
        self.assertEqual(config.dates_of_birth, True)  # Default value

    def test_sensitive_info_config(self):
        """Test SensitiveInfoConfig model."""
        config = SensitiveInfoConfig(
            enable_pii=False, enable_phi=True, custom_entities=["employee IDs"]
        )

        self.assertEqual(config.enable_pii, False)
        self.assertEqual(config.enable_phi, True)
        self.assertEqual(config.custom_entities, ["employee IDs"])
        self.assertIsInstance(config.pii_config, PIIConfig)
        self.assertIsInstance(config.phi_config, PHIConfig)


if __name__ == "__main__":
    unittest.main()
