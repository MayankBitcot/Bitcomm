"""
Test suite for the document loader functionality using real files and loaders.
Scenarios covered:
- Scenario 1: Use default loader which package provides
- Scenario 2: Override default PDF loader
- Scenario 3: Override default CSV loader
- Scenario 4: Override default PDF Loader and default CSV loader
- Scenario 5: Override default CSV Loader and default PDF loader
- Scenario 6: Override default PDF loader - Pass config
- Scenario 7: Override default CSV loader - Pass config
"""

import os
import unittest
import warnings

import pandas as pd
from langchain_community.document_loaders import (
    CSVLoader,
    Docx2txtLoader,
    PyMuPDFLoader,
    TextLoader,
    UnstructuredMarkdownLoader,
)
from langchain_community.document_loaders.base import BaseLoader
from langchain_core.documents import Document

from ragent.loader.app import load_document
from ragent.loader.constants import LOADER_REGISTRY
from ragent.loader.utils import detect_format, process_document_as_dict

# Filter out specific SWIG-related warnings from PyMuPDF
warnings.filterwarnings(
    "ignore",
    category=DeprecationWarning,
    message="builtin type SwigPyObject has no __module__ attribute",
)
warnings.filterwarnings(
    "ignore",
    category=DeprecationWarning,
    message="builtin type SwigPyPacked has no __module__ attribute",
)
warnings.filterwarnings(
    "ignore",
    category=DeprecationWarning,
    message="builtin type swigvarlink has no __module__ attribute",
)


CUSTOM_PDF_LOADER_CONTENT = "Custom PDF Loader Content"
CUSTOM_CSV_LOADER_CONTENT = "Custom CSV Loader Content"


class BaseLoaderTestCase(unittest.TestCase):
    """Base test case for loader tests, providing common setup functionality."""

    def setUp(self):
        """Set up paths to test files from the tests/test_data directory."""
        # Get the absolute path to the test_data directory
        current_dir = os.path.dirname(os.path.abspath(__file__))
        self.test_data_dir = os.path.join(current_dir, "test_data")

        # Define paths to each sample file
        self.text_file = os.path.join(self.test_data_dir, "sample.txt")
        self.csv_file = os.path.join(self.test_data_dir, "sample.csv")
        self.md_file = os.path.join(self.test_data_dir, "README.md")
        self.docx_file = os.path.join(self.test_data_dir, "sample.docx")
        self.pdf_file = os.path.join(self.test_data_dir, "sample.pdf")

        # Verify that the files exist
        for file_path in [
            self.text_file,
            self.csv_file,
            self.md_file,
            self.docx_file,
            self.pdf_file,
        ]:
            self.assertTrue(
                os.path.exists(file_path), f"Test file {file_path} not found"
            )


class DirectLoaderTests(BaseLoaderTestCase):
    """
    Tests to directly use the real loader classes without going through the load_document function.

    Primarily covers Scenario 1: Use default loader which package provides
    """

    def load_and_verify(self, loader, file_path):
        documents = loader.load()
        self.assertGreater(
            len(documents),
            0,
            f"Loader should produce at least one document for {file_path}",
        )
        self.assertTrue(documents[0].page_content.strip())
        self.assertIn("source", documents[0].metadata)
        self.assertEqual(documents[0].metadata["source"], file_path)
        return documents

    # Scenario 1: Use default loader which package provides
    def test_text_loader_direct(self):
        """Test TextLoader directly with a real text file (Scenario 1)."""
        loader = TextLoader(self.text_file)
        self.load_and_verify(loader, self.text_file)

    # Scenario 1: Use default loader which package provides
    def test_csv_loader_direct(self):
        """Test CSVLoader directly with a real CSV file (Scenario 1)."""
        loader = CSVLoader(self.csv_file)
        documents = self.load_and_verify(loader, self.csv_file)

        # Additional CSV-specific checks
        df = pd.read_csv(self.csv_file)
        headers = df.columns.tolist()
        self.assertTrue(any(header in documents[0].page_content for header in headers))

        if "source" in headers:
            source_loader = CSVLoader(self.csv_file, source_column="source")
            source_documents = source_loader.load()
            self.assertIn("source", source_documents[0].metadata)

    # Scenario 1: Use default loader which package provides
    def test_markdown_loader_direct(self):
        """Test UnstructuredMarkdownLoader directly with a real Markdown file (Scenario 1)."""
        loader = UnstructuredMarkdownLoader(self.md_file)
        self.load_and_verify(loader, self.md_file)

    # Scenario 1: Use default loader which package provides
    def test_docx_loader_direct(self):
        """Test Docx2txtLoader directly with a real DOCX file (Scenario 1)."""
        loader = Docx2txtLoader(self.docx_file)
        self.load_and_verify(loader, self.docx_file)

    # Scenario 1: Use default loader which package provides
    def test_pdf_loader_direct(self):
        """Test PyMuPDFLoader directly with a real PDF file (Scenario 1)."""
        loader = PyMuPDFLoader(self.pdf_file)
        self.load_and_verify(loader, self.pdf_file)

    # Scenario 1: Use default loader which package provides
    def test_loader_registry_classes(self):
        """Test that the loader registry contains the correct loader classes (Scenario 1)."""
        self.assertIs(LOADER_REGISTRY["txt"], TextLoader)
        self.assertIs(LOADER_REGISTRY["csv"], CSVLoader)
        self.assertIs(LOADER_REGISTRY["md"], UnstructuredMarkdownLoader)
        self.assertIs(LOADER_REGISTRY["docx"], Docx2txtLoader)
        self.assertIs(LOADER_REGISTRY["pdf"], PyMuPDFLoader)

    # Scenario 6/7: Pass configs to default loaders
    def test_custom_loader_options(self):
        """Test that the loaders accept custom initialization options (Scenario 6/7)."""
        # Test TextLoader with custom encoding
        text_loader = TextLoader(self.text_file, encoding="utf-8")
        text_docs = text_loader.load()
        self.assertGreater(len(text_docs), 0)

        # Test CSVLoader with custom options
        csv_loader = CSVLoader(self.csv_file, csv_args={"delimiter": ","})
        csv_docs = csv_loader.load()
        self.assertGreater(len(csv_docs), 0)


class RealLoaderIntegrationTests(BaseLoaderTestCase):
    """
    Integration tests for document loaders using real files and real loaders.
    These tests validate the actual functionality of loaders with various file types.

    Primarily covers Scenario 1: Use default loader which package provides
    """

    def load_and_verify_integration(self, file_path):
        documents = load_document(file_path)
        self.assertGreater(
            len(documents), 0, f"File {file_path} should produce at least one document"
        )
        self.assertTrue(documents[0].page_content.strip())
        return documents

    # Scenario 1: Use default loader which package provides
    def test_load_text_file(self):
        """Test loading a real text file (Scenario 1)."""
        documents = self.load_and_verify_integration(self.text_file)
        self.assertIn("source", documents[0].metadata)
        self.assertEqual(documents[0].metadata["source"], self.text_file)

    # Scenario 1: Use default loader which package provides
    def test_load_csv_file(self):
        """Test loading a real CSV file (Scenario 1)."""
        self.load_and_verify_integration(self.csv_file)

        df = pd.read_csv(self.csv_file)
        if "source" in df.columns:
            documents_with_source = load_document(self.csv_file, source_column="source")
            for doc in documents_with_source:
                self.assertIn("source", doc.metadata)
                self.assertIn(doc.metadata["source"], df["source"].values)

    # Scenario 1: Use default loader which package provides
    def test_load_markdown_file(self):
        """Test loading a real Markdown file (Scenario 1)."""
        self.load_and_verify_integration(self.md_file)

    # Scenario 1: Use default loader which package provides
    def test_load_docx_file(self):
        """Test loading a real DOCX file (Scenario 1)."""
        self.load_and_verify_integration(self.docx_file)

    # Scenario 1: Use default loader which package provides
    def test_load_pdf_file(self):
        """Test loading a real PDF file (Scenario 1)."""
        self.load_and_verify_integration(self.pdf_file)

    # Scenario 1: Use default loader which package provides
    def test_process_document_as_dict_all_formats(self):
        """Test processing documents into dictionary format for all file types (Scenario 1)."""
        file_formats = [
            (self.text_file, "txt"),
            (self.csv_file, "csv"),
            (self.md_file, "md"),
            (self.docx_file, "docx"),
            (self.pdf_file, "pdf"),
        ]

        for file_path, extension in file_formats:
            documents = load_document(file_path)
            result = process_document_as_dict(
                documents=documents,
                file_name=os.path.basename(file_path),
                file_extension=extension,
            )

            self.assertIn("_metadata", result)
            self.assertEqual(result["_metadata"]["file_type"], extension)
            self.assertGreater(result["_metadata"]["num_chunks"], 0)
            self.assertIn("chunk_0", result)
            self.assertIn("content", result["chunk_0"])
            self.assertIn("metadata", result["chunk_0"])

    # Scenarios 6/7: Pass config to default loaders
    def test_load_with_custom_parameters(self):
        """Test loading documents with custom parameters for each loader type (Scenarios 6/7)."""
        # Test text loader with custom encoding
        text_params = {"encoding": "utf-8"}
        text_docs = load_document(self.text_file, loader_params=text_params)
        self.assertGreater(len(text_docs), 0)

        # Test CSV loader with custom parameters
        csv_params = {"csv_args": {"delimiter": ","}}
        csv_docs = load_document(self.csv_file, loader_params=csv_params)
        self.assertGreater(len(csv_docs), 0)

        # Test PDF loader with custom parameters
        pdf_params = {"extract_images": False}
        pdf_docs = load_document(self.pdf_file, loader_params=pdf_params)
        self.assertGreater(len(pdf_docs), 0)


class RealLoaderAutoDetectionTests(BaseLoaderTestCase):
    """
    Tests that validate the auto-detection functionality works with real files.

    Primarily covers Scenario 1: Use default loader which package provides
    """

    # Scenario 1: Use default loader which package provides
    def test_auto_detect_formats(self):
        """Test that file formats are correctly auto-detected (Scenario 1)."""
        format_pairs = [
            (self.text_file, "txt"),
            (self.csv_file, "csv"),
            (self.md_file, "md"),
            (self.docx_file, "docx"),
            (self.pdf_file, "pdf"),
        ]

        for file_path, expected_format in format_pairs:
            detected_format = detect_format(file_path)
            self.assertEqual(detected_format, expected_format)

    # Scenario 1: Use default loader which package provides
    def test_load_with_auto_detection(self):
        """Test loading documents with auto-detected format (Scenario 1)."""
        file_paths = [
            self.text_file,
            self.csv_file,
            self.md_file,
            self.docx_file,
            self.pdf_file,
        ]

        for file_path in file_paths:
            documents = load_document(file_path)
            self.assertGreater(
                len(documents),
                0,
                f"File {file_path} should produce at least one document",
            )
            self.assertTrue(documents[0].page_content.strip())


class LoaderOverrideTests(unittest.TestCase):
    """
    Tests that specifically cover scenarios for overriding default loaders.

    Scenarios covered:
    - Scenario 2: Override default PDF loader
    - Scenario 3: Override default CSV loader
    - Scenario 4: Override default PDF Loader and default CSV loader
    - Scenario 5: Override default CSV Loader and default PDF loader
    - Scenario 6: Override default PDF loader - Pass config
    - Scenario 7: Override default CSV loader - Pass config
    """

    def setUp(self):
        """Set up paths to test files and create custom loaders."""
        current_dir = os.path.dirname(os.path.abspath(__file__))
        self.test_data_dir = os.path.join(current_dir, "test_data")
        self.csv_file = os.path.join(self.test_data_dir, "sample.csv")
        self.pdf_file = os.path.join(self.test_data_dir, "sample.pdf")
        self.assertTrue(os.path.exists(self.csv_file))
        self.assertTrue(os.path.exists(self.pdf_file))
        self.original_registry = LOADER_REGISTRY.copy()

    def tearDown(self):
        """Restore original registry state after each test."""
        global LOADER_REGISTRY
        LOADER_REGISTRY.clear()
        LOADER_REGISTRY.update(self.original_registry)

    def create_custom_loader(self, content, loader_type):
        """Helper method to create a custom loader with specified content and type."""

        class CustomLoader(BaseLoader):
            def __init__(self, file_path, **kwargs):
                self.file_path = file_path
                self.kwargs = kwargs

            def load(self):
                return [
                    Document(
                        page_content=content,
                        metadata={
                            "source": self.file_path,
                            "loader_type": loader_type,
                        },
                    )
                ]

        return CustomLoader

    def override_and_test_loaders(self, pdf_loader, csv_loader):
        """Helper method to override loaders and test loading documents."""
        original_pdf_loader = LOADER_REGISTRY["pdf"]
        original_csv_loader = LOADER_REGISTRY["csv"]
        try:
            LOADER_REGISTRY["pdf"] = pdf_loader
            LOADER_REGISTRY["csv"] = csv_loader

            pdf_documents = load_document(self.pdf_file)
            csv_documents = load_document(self.csv_file)

            self.assertEqual(len(pdf_documents), 1)
            self.assertEqual(pdf_documents[0].page_content, CUSTOM_PDF_LOADER_CONTENT)
            self.assertEqual(pdf_documents[0].metadata["loader_type"], "custom_pdf")

            self.assertEqual(len(csv_documents), 1)
            self.assertEqual(csv_documents[0].page_content, CUSTOM_CSV_LOADER_CONTENT)
            self.assertEqual(csv_documents[0].metadata["loader_type"], "custom_csv")
        finally:
            LOADER_REGISTRY["pdf"] = original_pdf_loader
            LOADER_REGISTRY["csv"] = original_csv_loader

    def test_override_pdf_loader(self):
        """Test Scenario 2: Override default PDF loader."""
        custom_pdf_loader = self.create_custom_loader(
            CUSTOM_PDF_LOADER_CONTENT, "custom_pdf"
        )
        original_pdf_loader = LOADER_REGISTRY["pdf"]
        try:
            LOADER_REGISTRY["pdf"] = custom_pdf_loader
            documents = load_document(self.pdf_file)
            self.assertEqual(len(documents), 1)
            self.assertEqual(documents[0].page_content, CUSTOM_PDF_LOADER_CONTENT)
            self.assertEqual(documents[0].metadata["loader_type"], "custom_pdf")
        finally:
            LOADER_REGISTRY["pdf"] = original_pdf_loader

    def test_override_csv_loader(self):
        """Test Scenario 3: Override default CSV loader."""
        custom_csv_loader = self.create_custom_loader(
            CUSTOM_CSV_LOADER_CONTENT, "custom_csv"
        )
        original_csv_loader = LOADER_REGISTRY["csv"]
        try:
            LOADER_REGISTRY["csv"] = custom_csv_loader
            documents = load_document(self.csv_file)
            self.assertEqual(len(documents), 1)
            self.assertEqual(documents[0].page_content, CUSTOM_CSV_LOADER_CONTENT)
            self.assertEqual(documents[0].metadata["loader_type"], "custom_csv")
        finally:
            LOADER_REGISTRY["csv"] = original_csv_loader

    def test_override_pdf_and_csv_loaders(self):
        """Test Scenario 4: Override default PDF Loader and default CSV loader."""
        custom_pdf_loader = self.create_custom_loader(
            CUSTOM_PDF_LOADER_CONTENT, "custom_pdf"
        )
        custom_csv_loader = self.create_custom_loader(
            CUSTOM_CSV_LOADER_CONTENT, "custom_csv"
        )
        self.override_and_test_loaders(custom_pdf_loader, custom_csv_loader)

    def test_override_csv_and_pdf_loaders(self):
        """Test Scenario 5: Override default CSV Loader and default PDF loader."""
        custom_pdf_loader = self.create_custom_loader(
            CUSTOM_PDF_LOADER_CONTENT, "custom_pdf"
        )
        custom_csv_loader = self.create_custom_loader(
            CUSTOM_CSV_LOADER_CONTENT, "custom_csv"
        )
        self.override_and_test_loaders(custom_pdf_loader, custom_csv_loader)

    def test_override_pdf_loader_with_config(self):
        """Test Scenario 6: Override default PDF loader - Pass config."""

        class ConfigurablePDFLoader(BaseLoader):
            def __init__(self, file_path, **kwargs):
                self.file_path = file_path
                self.extract_images = kwargs.get("extract_images", True)
                self.password = kwargs.get("password", None)
                self.kwargs = kwargs

            def load(self):
                # Return a document with the configuration info to verify it was passed
                return [
                    Document(
                        page_content=f"""
                        PDF content with extract_images={self.extract_images},
                        password={self.password}
                        """,
                        metadata={
                            "source": self.file_path,
                            "loader_type": "configurable_pdf",
                            "extract_images": self.extract_images,
                            "password": self.password,
                        },
                    )
                ]

        original_pdf_loader = LOADER_REGISTRY["pdf"]
        try:
            LOADER_REGISTRY["pdf"] = ConfigurablePDFLoader
            pdf_params = {"extract_images": False, "password": "test123"}
            documents = load_document(self.pdf_file, loader_params=pdf_params)
            self.assertEqual(len(documents), 1)
            self.assertEqual(documents[0].metadata["loader_type"], "configurable_pdf")
            self.assertFalse(documents[0].metadata["extract_images"])
            self.assertEqual(documents[0].metadata["password"], "test123")
        finally:
            LOADER_REGISTRY["pdf"] = original_pdf_loader

    def test_override_csv_loader_with_config(self):
        """Test Scenario 7: Override default CSV loader - Pass config."""

        class ConfigurableCSVLoader(BaseLoader):
            def __init__(self, file_path, **kwargs):
                self.file_path = file_path
                self.delimiter = kwargs.get("csv_args", {}).get("delimiter", ",")
                self.quotechar = kwargs.get("csv_args", {}).get("quotechar", '"')
                self.source_column = kwargs.get("source_column")
                self.kwargs = kwargs

            def load(self):
                # Return a document with the configuration info to verify it was passed
                return [
                    Document(
                        page_content=f"""
                        CSV content with delimiter='{self.delimiter}',quotechar='{self.quotechar}',
                        source_column='{self.source_column}'
                        """,
                        metadata={
                            "source": self.file_path,
                            "loader_type": "configurable_csv",
                            "delimiter": self.delimiter,
                            "quotechar": self.quotechar,
                            "source_column": self.source_column,
                        },
                    )
                ]

        original_csv_loader = LOADER_REGISTRY["csv"]
        try:
            LOADER_REGISTRY["csv"] = ConfigurableCSVLoader
            csv_params = {"csv_args": {"delimiter": "|", "quotechar": "'"}}
            documents = load_document(
                self.csv_file, source_column="source", loader_params=csv_params
            )
            self.assertEqual(len(documents), 1)
            self.assertEqual(documents[0].metadata["loader_type"], "configurable_csv")
            self.assertEqual(documents[0].metadata["delimiter"], "|")
            self.assertEqual(documents[0].metadata["quotechar"], "'")
            self.assertEqual(documents[0].metadata["source_column"], "source")
        finally:
            LOADER_REGISTRY["csv"] = original_csv_loader

    def test_custom_loader_via_loader_config(self):
        """Test using a custom loader directly via loader_config parameter."""

        class CustomDirectLoader(BaseLoader):
            def __init__(self, file_path, **kwargs):
                self.file_path = file_path
                self.kwargs = kwargs

            def load(self):
                return [
                    Document(
                        page_content="Custom Direct Loader Content",
                        metadata={
                            "source": self.file_path,
                            "loader_type": "direct_custom",
                        },
                    )
                ]

        custom_loader = CustomDirectLoader(self.pdf_file)
        documents = load_document(self.pdf_file, loader_config=custom_loader)
        self.assertEqual(len(documents), 1)
        self.assertEqual(documents[0].page_content, "Custom Direct Loader Content")
        self.assertEqual(documents[0].metadata["loader_type"], "direct_custom")


if __name__ == "__main__":
    unittest.main()
