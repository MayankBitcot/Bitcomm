import unittest
from unittest.mock import MagicMock, mock_open, patch

import openai

from ragent.connectors.llm.stt.openai import OpenAISpeechToText
from ragent.core.stt import SpeechToTextError
from ragent.openai_constants import OpenAIConfig


class TestOpenAISpeechToText(unittest.TestCase):
    """Test cases for the OpenAISpeechToText class."""

    def setUp(self):
        """Set up test environment before each test."""
        # Create a mock API key for testing
        self.mock_api_key = "mock-api-key-for-testing"
        # Create a patch for OpenAIConfig.API_KEY
        self.config_patcher = patch.object(OpenAIConfig, "API_KEY", self.mock_api_key)
        self.config_patcher.start()

    def tearDown(self):
        """Clean up after each test."""
        self.config_patcher.stop()

    @patch("os.environ")
    @patch("openai.OpenAI")
    def test_initialization(self, mock_openai, mock_environ):
        """Test that the class initializes correctly with API key."""
        # Arrange & Act
        stt = OpenAISpeechToText()

        # Assert
        mock_environ.__setitem__.assert_called_once_with(
            "OPENAI_API_KEY", self.mock_api_key
        )
        mock_openai.assert_called_once()
        self.assertIsNotNone(stt.client)

    @patch("openai.OpenAI")
    @patch.object(OpenAIConfig, "API_KEY", "mock-api-key")  # Ensure API_KEY is a string
    def test_initialization_import_error(self, mock_openai):
        """Test that an ImportError is raised when openai is not available."""
        # Arrange
        mock_openai.side_effect = ImportError("Module not found")

        # Act & Assert
        with self.assertRaises(ImportError) as context:
            OpenAISpeechToText()

        self.assertIn("openai is not installed", str(context.exception))

    @patch("builtins.open", new_callable=mock_open, read_data=b"audio data")
    def test_speech_to_text_successful(self, mock_file):
        """Test successful transcription of an audio file."""
        # Arrange
        # Create the instance outside the main test to avoid the initialization error
        with patch("openai.OpenAI"):
            stt = OpenAISpeechToText()

        mock_client = MagicMock()
        mock_response = "Transcribed text"
        mock_client.audio.transcriptions.create.return_value = mock_response
        stt.client = mock_client

        test_path = "test_audio.mp3"
        test_prompt = "Test prompt"
        test_model = "whisper-1"

        # Act
        result = stt._speech_to_text(test_path, test_prompt, test_model)

        # Assert
        mock_file.assert_called_once_with(test_path, "rb")
        mock_client.audio.transcriptions.create.assert_called_once_with(
            model=test_model,
            file=mock_file(),
            response_format="text",
            prompt=test_prompt,
        )
        self.assertEqual(result, "Transcribed text")

    @patch("builtins.open", new_callable=mock_open, read_data=b"audio data")
    def test_speech_to_text_default_model(self, mock_file):
        """Test that the default model is used when not specified."""
        # Arrange
        with patch("openai.OpenAI"):
            stt = OpenAISpeechToText()

        mock_client = MagicMock()
        mock_response = "Transcribed text"
        mock_client.audio.transcriptions.create.return_value = mock_response
        stt.client = mock_client

        test_path = "test_audio.mp3"

        # Act
        result = stt._speech_to_text(test_path)

        # Assert
        mock_client.audio.transcriptions.create.assert_called_once_with(
            model=OpenAIConfig.STT_MODEL_NAME,
            file=mock_file(),
            response_format="text",
            prompt=None,
        )
        self.assertEqual(result, "Transcribed text")

    @patch("builtins.open", new_callable=mock_open, read_data=b"audio data")
    def test_speech_to_text_api_error(self, mock_file):
        """Test handling of OpenAI API errors."""
        # Arrange
        with patch("openai.OpenAI"):
            stt = OpenAISpeechToText()

        mock_client = MagicMock()
        # Create a properly formatted APIStatusError
        mock_response = MagicMock()
        mock_response.status_code = 500
        mock_response.json.return_value = {"error": "Server error"}

        mock_client.audio.transcriptions.create.side_effect = openai.BadRequestError(
            message="API Error", response=mock_response, body={"error": "Server error"}
        )

        stt.client = mock_client
        test_path = "test_audio.mp3"

        # Act & Assert
        with self.assertRaises(SpeechToTextError) as context:
            stt._speech_to_text(test_path)

        self.assertIn("OpenAI API error during transcription", str(context.exception))

    @patch("builtins.open", new_callable=mock_open, read_data=b"audio data")
    def test_speech_to_text_connection_error(self, mock_file):
        """Test handling of connection errors."""
        # Arrange
        with patch("openai.OpenAI"):
            stt = OpenAISpeechToText()

        mock_client = MagicMock()
        # Create a properly formatted APIConnectionError with the required 'request' argument
        mock_request = MagicMock()
        mock_client.audio.transcriptions.create.side_effect = openai.APIConnectionError(
            message="Connection Error", request=mock_request
        )

        stt.client = mock_client
        test_path = "test_audio.mp3"

        # Act & Assert
        with self.assertRaises(SpeechToTextError) as context:
            stt._speech_to_text(test_path)

        self.assertIn("OpenAI API error during transcription", str(context.exception))

    @patch("builtins.open", new_callable=mock_open, read_data=b"audio data")
    def test_speech_to_text_rate_limit_error(self, mock_file):
        """Test handling of rate limit errors."""
        # Arrange
        with patch("openai.OpenAI"):
            stt = OpenAISpeechToText()

        mock_client = MagicMock()
        # Create a properly formatted RateLimitError with required arguments
        mock_response = MagicMock()
        mock_response.status_code = 429
        mock_response.json.return_value = {"error": "Rate limit exceeded"}

        mock_client.audio.transcriptions.create.side_effect = openai.RateLimitError(
            message="Rate limit exceeded",
            response=mock_response,
            body={"error": "Rate limit exceeded"},
        )

        stt.client = mock_client
        test_path = "test_audio.mp3"

        # Act & Assert
        with self.assertRaises(SpeechToTextError) as context:
            stt._speech_to_text(test_path)

        self.assertIn("OpenAI API error during transcription", str(context.exception))

    @patch("builtins.open", new_callable=mock_open, read_data=b"audio data")
    def test_speech_to_text_unexpected_error(self, mock_file):
        """Test handling of unexpected errors."""
        # Arrange
        with patch("openai.OpenAI"):
            stt = OpenAISpeechToText()

        mock_client = MagicMock()
        mock_client.audio.transcriptions.create.side_effect = Exception(
            "Unexpected error"
        )

        stt.client = mock_client
        test_path = "test_audio.mp3"

        # Act & Assert
        with self.assertRaises(SpeechToTextError) as context:
            stt._speech_to_text(test_path)

        self.assertIn(
            "An unexpected error occurred during transcription", str(context.exception)
        )

    @patch("builtins.open")
    def test_speech_to_text_file_not_found(self, mock_file):
        """Test handling of file not found errors."""
        # Arrange
        with patch("openai.OpenAI"):
            stt = OpenAISpeechToText()

        mock_file.side_effect = FileNotFoundError("File not found")
        test_path = "nonexistent_audio.mp3"

        # Act & Assert
        with self.assertRaises(SpeechToTextError) as context:
            stt._speech_to_text(test_path)

        self.assertIn(
            "An unexpected error occurred during transcription", str(context.exception)
        )

    @patch("builtins.open", new_callable=mock_open, read_data=b"audio data")
    def test_speech_to_text_whitespace_handling(self, mock_file):
        """Test that whitespace is properly stripped from the response."""
        # Arrange
        with patch("openai.OpenAI"):
            stt = OpenAISpeechToText()

        mock_client = MagicMock()
        mock_response = "  Transcribed text with whitespace  "

        mock_client.audio.transcriptions.create.return_value = mock_response

        stt.client = mock_client
        test_path = "test_audio.mp3"

        # Act
        result = stt._speech_to_text(test_path)

        # Assert
        self.assertEqual(result, "Transcribed text with whitespace")

    @patch(
        "ragent.connectors.llm.stt.openai.logger"
    )  # Patch the logger at the exact module path
    @patch("builtins.open", new_callable=mock_open, read_data=b"audio data")
    def test_speech_to_text_logging(self, mock_file, mock_logger):
        """Test that logging is performed correctly."""
        # Arrange
        with patch("openai.OpenAI"):
            stt = OpenAISpeechToText()

        mock_client = MagicMock()
        mock_response = "This is a test transcription"

        mock_client.audio.transcriptions.create.return_value = mock_response

        stt.client = mock_client
        test_path = "test_audio.mp3"

        # Act
        stt._speech_to_text(test_path)

        # Assert
        # Check that the logger.info method was called with the expected argument
        mock_logger.info.assert_called_once_with(
            f"Transcribed text (first 50 chars): {mock_response[:50]}..."
        )
