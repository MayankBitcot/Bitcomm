"""
Utility functions for Whisper transcription package
"""

import os
import tempfile
from pathlib import Path
from typing import BinaryIO, Optional, Union

from .exceptions import AudioValidationError


def detect_file_extension(
    filename: Optional[str] = None, content_type: Optional[str] = None
) -> str:
    """
    Detect file extension from filename or content type.

    Args:
        filename: Audio filename
        content_type: MIME type of the audio file

    Returns:
        File extension with leading dot (e.g., '.webm', '.mp3')
    """
    # Try filename first
    if filename:
        filename_lower = filename.lower()
        extensions = [".mp4", ".webm", ".ogg", ".wav", ".mp3", ".m4a", ".flac", ".aac"]
        for ext in extensions:
            if filename_lower.endswith(ext):
                return ext

    # Try content type
    if content_type:
        content_type_lower = content_type.lower()
        mime_to_ext = {
            "audio/mp4": ".mp4",
            "audio/mpeg": ".mp3",
            "audio/webm": ".webm",
            "audio/ogg": ".ogg",
            "audio/wav": ".wav",
            "audio/wave": ".wav",
            "audio/x-wav": ".wav",
            "audio/m4a": ".m4a",
            "audio/x-m4a": ".m4a",
            "audio/flac": ".flac",
            "audio/aac": ".aac",
        }
        for mime, ext in mime_to_ext.items():
            if mime in content_type_lower:
                return ext

    # Default to webm
    return ".webm"


def validate_audio_size(audio_data: bytes, min_size: int = 1024) -> None:
    """
    Validate that audio data is not too small (likely empty).

    Args:
        audio_data: Audio file bytes
        min_size: Minimum size in bytes (default: 1024)

    Raises:
        AudioValidationError: If audio is too small
    """
    if len(audio_data) < min_size:
        raise AudioValidationError(
            f"Audio file too small ({len(audio_data)} bytes), likely empty recording. "
            f"Minimum size: {min_size} bytes"
        )


def create_temp_audio_file(audio_data: bytes, file_extension: str) -> str:
    """
    Create a temporary audio file from bytes.

    Args:
        audio_data: Audio file bytes
        file_extension: File extension with leading dot

    Returns:
        Path to temporary file
    """
    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=file_extension)
    temp_file.write(audio_data)
    temp_file_path = temp_file.name
    temp_file.close()
    return temp_file_path


def cleanup_temp_file(file_path: str) -> None:
    """
    Safely delete a temporary file.

    Args:
        file_path: Path to file to delete
    """
    try:
        if os.path.exists(file_path):
            os.unlink(file_path)
    except Exception as e:
        # Log but don't raise - cleanup failures shouldn't break the flow
        print(f"Warning: Failed to delete temp file {file_path}: {str(e)}")


def read_audio_file(file_path: Union[str, Path, BinaryIO]) -> bytes:
    """
    Read audio file from various input types.

    Args:
        file_path: Path to file, Path object, or file-like object

    Returns:
        Audio file bytes
    """
    if isinstance(file_path, (str, Path)):
        with open(file_path, "rb") as f:
            return f.read()
    elif hasattr(file_path, "read"):
        # File-like object
        if hasattr(file_path, "seek"):
            file_path.seek(0)
        return file_path.read()
    else:
        raise ValueError(f"Unsupported file input type: {type(file_path)}")
