import re
import time

from ragent.llms.main import get_chat_litellm
from ragent.log_utils import logger
from ragent.openai_constants import OpenAIConfig
from ragent.prompts.ragbase import REPHRASE_PROMPT


class InputRephraser:
    """
    Handles user input rephrasing functionality.

    This class is responsible for:
    1. Rephrasing user input using conversation context
    2. Cleaning citation references from text
    3. Formatting conversation history for rephrasing
    """

    def __init__(self):
        pass

    async def rephrase_user_input(
        self,
        user_input: str,
        message_log: list,
    ) -> str:
        """
        Rephrase the user input using the REPHRASE_PROMPT.

        Args:
            user_input: The original user input
            message_log: The conversation message log

        Returns:
            str: The rephrased user input
        """
        try:
            start_rephrase = time.time()

            logger.info("Starting user input rephrasing")

            # Format conversation history from message log
            conversation_history = self._format_conversation_history(message_log)

            # Format the rephrase prompt
            rephrase_prompt = REPHRASE_PROMPT.format(
                question=user_input, conversation_history=conversation_history
            )

            logger.info(f"Cleaned conversation history: {conversation_history}")

            # Create LLM client for rephrasing
            llm = get_chat_litellm(
                model=OpenAIConfig.CHAT_MODEL_NAME,
                api_key=OpenAIConfig.API_KEY,
                max_retries=OpenAIConfig.MAX_RETRIES,
                streaming=False,
                callbacks=[],
            )

            response = await llm.ainvoke(rephrase_prompt)
            end_rephrase = time.time()

            rephrased_input = response.content.strip()

            logger.info(f"Rephrase time: {(end_rephrase - start_rephrase):.2f} seconds")
            logger.info(f"Rephrased input: {rephrased_input}")

            return rephrased_input

        except Exception as e:
            logger.error(f"Error during user input rephrasing: {e}")
            logger.warning("Falling back to original user input")
            return user_input

    def _format_conversation_history(self, message_log: list) -> str:
        """
        Format conversation history from message log.

        Args:
            message_log: The conversation message log

        Returns:
            str: Formatted conversation history
        """
        conversation_history = ""

        if message_log:
            # Convert message log to conversation history format
            for i in range(0, len(message_log), 2):
                if i < len(message_log):
                    human_msg = message_log[i]
                    ai_msg = message_log[i + 1] if i + 1 < len(message_log) else ""

                    conversation_history += f"Human: {human_msg}\n"
                    if ai_msg:
                        # Clean the assistant message by removing citations
                        cleaned_ai_msg = self.remove_citations(ai_msg)
                        conversation_history += f"Assistant: {cleaned_ai_msg}\n"

        return conversation_history

    def remove_citations(self, text: str) -> str:
        """
        Remove citations from the assistant response text.

        Args:
            text: The original assistant response text

        Returns:
            str: The cleaned text without citations
        """
        try:
            # Remove markdown links with any file extensions (pdf, txt, doc, etc.)
            # Pattern: [filename.ext](url) or [filename.ext#section](url)
            text = re.sub(r"\[([^\]]+\.[a-zA-Z0-9]+[^\]]*)\]\([^)]*\)", "", text)

            # Remove incomplete citation links (in case the above didn't catch them)
            # Pattern: [filename.ext]( or [filename.ext#section](
            text = re.sub(r"\[([^\]]+\.[a-zA-Z0-9]+[^\]]*)\]\([^)]*", "", text)

            # Remove any remaining standalone markdown link patterns
            text = re.sub(r"\[[^\]]*\]\([^)]*\)", "", text)

            # Remove standalone URLs that might be citations
            text = re.sub(r"https?://[^\s]+", "", text)

            # Remove any remaining incomplete URLs or fragments
            text = re.sub(r"https?://[^\s)]*", "", text)

            # Clean up any remaining citation-like patterns
            # Remove lines that start with just [ and contain file extensions
            lines = text.split("\n")
            cleaned_lines = []
            for line in lines:
                cleaned_line = line.strip()
                # Skip lines that look like incomplete citations
                if not (
                    cleaned_line.startswith("[")
                    and any(
                        ext in cleaned_line
                        for ext in [".pdf", ".txt", ".doc", ".docx", ".xls", ".xlsx"]
                    )
                ):
                    if cleaned_line:  # Only keep non-empty lines
                        cleaned_lines.append(line)

            # Join back and clean up multiple newlines
            cleaned_text = "\n".join(cleaned_lines)

            # Remove excessive whitespace and newlines
            cleaned_text = re.sub(
                r"\n\s*\n\s*\n+", "\n\n", cleaned_text
            )  # Max 2 consecutive newlines
            cleaned_text = re.sub(
                r"\n\s*\n$", "", cleaned_text
            )  # Remove trailing newlines
            cleaned_text = cleaned_text.strip()

            logger.debug(
                f"Original text length: {len(text)}, Cleaned text length: {len(cleaned_text)}"
            )

            return cleaned_text

        except Exception as e:
            logger.error(f"Error removing citations: {e}")
            return text  # Return original text if cleaning fails
