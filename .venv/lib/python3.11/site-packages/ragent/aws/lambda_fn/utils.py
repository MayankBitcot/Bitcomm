import base64
import json
from functools import wraps
from http import HTTPStatus
from typing import Any, Callable, Dict, List, Tuple, Type, Union

from pydantic import BaseModel, ValidationError

from ragent.aws.cors import get_origins
from ragent.aws.rds.db import db
from ragent.log_utils import logger

EVENT_BODY = "Event body is base64 encoded. Decoding..."


def generate_headers(request_origin: str = None) -> Dict[str, str]:
    """Generate CORS headers."""
    logger.info(f"Generating headers for origin: {request_origin}")
    return {
        "Access-Control-Allow-Origin": "*",  # Default to allow all origins
        "Access-Control-Allow-Methods": "GET, POST, DELETE, OPTIONS, PUT",
        "Content-Type": "application/json",
        "Access-Control-Allow-Headers": "*",
    }


def get_event_data(event: Dict[str, Any]) -> Dict[str, Any]:
    logger.info("Getting event data...")

    # Try to get HTTP method from 'requestContext.http.method' or 'httpMethod'
    http_method = (
        event.get("requestContext", {}).get("http", {}).get("method", "").upper()
        or event.get("httpMethod", "").upper()
    )
    logger.info(f"HTTP Method {http_method}")
    if http_method == "GET":
        logger.debug("Processing GET request...")
        return event.get("queryStringParameters", {})
    elif http_method == "POST":
        logger.debug("Processing POST request...")
        if event.get("isBase64Encoded", False):
            logger.debug(EVENT_BODY)
            body = json.loads(base64.b64decode(event["body"]))
        else:
            logger.debug(EVENT_BODY)
            body = json.loads(event["body"])
        return body
    elif http_method == "DELETE":
        logger.debug("Processing DELETE request...")
        if event.get("isBase64Encoded", False):
            logger.debug(EVENT_BODY)
            body = json.loads(base64.b64decode(event["body"]))
        else:
            logger.debug(EVENT_BODY)
            body = json.loads(event["body"])
        return body
    elif http_method == "PUT":
        logger.debug("Processing PUT request...")
        if event.get("isBase64Encoded", False):
            logger.debug(EVENT_BODY)
            body = json.loads(base64.b64decode(event["body"]))
        else:
            logger.debug(EVENT_BODY)
            body = json.loads(event["body"])
        return body
    else:
        logger.debug("Unsupported HTTP method.")
        return {}


def handle_origin(request_origin: str, origins: List[str]) -> bool:
    """Check if the request origin is allowed."""
    if "*" in origins or request_origin == "*" or request_origin in origins:
        logger.debug("Origin allowed")
        return True
    return False


def call_fn(
    fn: Callable[
        [Dict[str, Union[str, Dict]], Any], Tuple[Union[Dict, BaseModel], int]
    ],
    event: Dict[str, Union[str, Dict]],
) -> Dict[str, Union[int, str, str]]:
    try:
        headers = event.get("headers", {}) or {}
        request_origin: str = headers.get("origin") or headers.get("Origin") or "*"
        logger.info(f"Request origin: {request_origin}")

        origins: List[str] = get_origins()
        logger.info(f"Allowed origins: {origins}")

        # Check if origin is allowed
        if not handle_origin(request_origin, origins):
            return {
                "statusCode": 403,
                "body": json.dumps(
                    {"status": False, "message": "CORS origin not allowed"}
                ),
                "headers": generate_headers(request_origin),
            }

        # Handle the HTTP method
        method = (
            event.get("httpMethod", "").upper()
            or event.get("requestContext", {}).get("http", {}).get("method", "").upper()
        )

        if method == "OPTIONS":
            return handle_options(request_origin)

        return handle_method(fn, event, request_origin)

    except Exception as e:
        logger.error(f"Error in call_fn: {str(e)}")
        return {
            "statusCode": 500,
            "body": json.dumps({"status": False, "message": "Internal server error"}),
            "headers": generate_headers("*"),
        }


def handle_options(request_origin: str) -> Dict[str, Any]:
    """Handle OPTIONS preflight request."""
    return {
        "statusCode": 200,
        "headers": generate_headers(request_origin),
        "body": "{}",
    }


def handle_method(
    fn: Callable,
    event: Dict[str, Union[str, Dict]],
    request_origin: str,
) -> Dict[str, Any]:
    """Handle method-specific requests."""
    try:
        data, status_code = fn(event, db)

        if isinstance(data, BaseModel):
            data = json.loads(data.model_dump_json())

        return {
            "statusCode": status_code,
            "body": json.dumps(data),
            "headers": generate_headers(request_origin),
        }

    except Exception as e:
        logger.error(f"Error executing function: {str(e)}")
        return {
            "statusCode": 500,
            "body": json.dumps({"status": False, "message": "Internal server error"}),
            "headers": generate_headers(request_origin),
        }


def payload_validator(model: Type[BaseModel]) -> Callable:
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            request = args[0]
            logger.info(f"Validating payload for {request}")

            logger.info(
                f"Validating payload for {request.get('httpMethod')} request..."
            )
            # Extract HTTP method from the top-level key and requestContext
            http_method = (
                request.get("requestContext", {})
                .get("http", {})
                .get("method", "")
                .upper()
            )
            http_method_top = request.get("httpMethod", "").upper()

            # Check if the HTTP method is GET or OPTIONS
            if http_method in ["GET", "OPTIONS"] or http_method_top in [
                "GET",
                "OPTIONS",
            ]:
                logger.info("Skipping payload validation for GET and OPTIONS requests.")
                # Skip validation for GET and OPTIONS requests
                return func(*args, **kwargs)

            data = get_event_data(request)
            logger.info(f"Payload: {data}")
            # Validate the payload structure
            try:
                logger.info("Validating payload...")
                model(**data)
                logger.info("Payload validation successful.")
            except ValidationError as ve:
                logger.error(f"Payload validation error: {ve}")
                return {
                    "statusCode": HTTPStatus.BAD_REQUEST,
                    "body": json.dumps(
                        {
                            "status": False,
                            "message": "Payload validation failed",
                        }
                    ),
                }
            except ValueError as ve:
                logger.error(f"Value error: {ve}")
                return {
                    "statusCode": HTTPStatus.BAD_REQUEST,
                    "body": json.dumps({"status": False, "message": str(ve)}),
                }

            return func(*args, **kwargs)

        return wrapper

    return decorator


# --- Lambda Context Stub ---
class Context:
    def __init__(self):
        self.function_name = "test_lambda"
        self.memory_limit_in_mb = 128
        self.invoked_function_arn = (
            "arn:aws:lambda:us-east-1:123456789012:function:test_lambda"
        )
        self.aws_request_id = "test-request-id"


# --- Decorator Wrapper ---
def lambda_event_wrapper(lambda_handler, request):
    @wraps(lambda_handler)
    def wrapped_handler(*args, **kwargs):
        event = {
            "body": json.dumps(request.get_json(silent=True) or {}),
            "headers": dict(request.headers),
            "httpMethod": request.method,
        }
        context = Context()
        response = lambda_handler(event, context)
        # If the handler returns dict-like object with 'statusCode' and 'body', unwrap it
        if (
            isinstance(response, dict)
            and "statusCode" in response
            and "body" in response
        ):
            return (
                response["body"],
                response["statusCode"],
                {"Content-Type": "application/json"},
            )
        return response

    return wrapped_handler
