import json
import logging
import os
from copy import deepcopy
from typing import Any, Dict, Optional

from ragent.voice_gateway.config.constants import AudioConfig, Headers, OpenAIConfig
from ragent.voice_gateway.interfaces.interfaces import IConfigService

logger = logging.getLogger(__name__)


class ConfigService(IConfigService):
    """Configuration service for managing all application settings"""

    def __init__(self, config_overrides: Dict[str, Any] = None):
        self._config_overrides = config_overrides or {}
        self._openai_config = None
        self._server_config = None
        self._audio_constraints = None
        self._runtime_voice_settings: Dict[str, Any] = {}
        self._initialize_configs()

    def _initialize_configs(self):
        """Initialize all configurations with validation"""
        self._openai_config = self._build_openai_config()
        self._server_config = self._build_server_config()
        self._audio_constraints = self._build_audio_constraints()

    def get_openai_config(self) -> Dict[str, Any]:
        """Get OpenAI configuration"""
        return self._openai_config.copy()

    def get_server_config(self) -> Dict[str, Any]:
        """Get server configuration"""
        return self._server_config.copy()

    def get_audio_constraints(self) -> Dict[str, Any]:
        """Get audio processing constraints"""
        return self._audio_constraints.copy()

    def _get_env_or_override(self, key: str, default: str = None) -> str:
        """Get value from environment or config overrides"""
        return self._config_overrides.get(key) or os.getenv(key) or default

    def _get_override_or_default(self, key: str, default: Any) -> Any:
        """Get value from overrides only (no environment fallback)"""
        return self._config_overrides.get(key, default)

    def _build_openai_config(self) -> Dict[str, Any]:
        """Build OpenAI configuration with validation"""
        api_key = self._get_env_or_override("OPENAI_API_KEY")
        if not api_key:
            raise ValueError("OPENAI_API_KEY is required but not found")

        # Get voice model and build websocket URL
        voice_model = self._get_override_or_default(
            "voice_model", OpenAIConfig.VOICE_MODEL
        )
        # Build websocket URL using pattern from OpenAIConfig.WEBSOCKET_URL constant
        # This shows how WebSocket connects to OpenAI Realtime API
        # See: OpenAIConfig.WEBSOCKET_URL in constants.py
        websocket_url = f"wss://api.openai.com/v1/realtime?model={voice_model}"

        # Get other settings with defaults matching realtime_api
        voice = self._get_override_or_default("voice", OpenAIConfig.VOICE)
        turn_detection_mode = self._normalize_turn_detection_mode(
            self._get_override_or_default(
                "turn_detection_mode", OpenAIConfig.TURN_DETECTION_MODE
            )
        )
        transcription_model = self._get_override_or_default(
            "transcription_model", OpenAIConfig.TRANSCRIPTION_MODEL
        )
        noise_reduction_mode = self._normalize_noise_reduction_mode(
            self._get_override_or_default(
                "noise_reduction_mode", OpenAIConfig.NOISE_REDUCTION_MODE
            )
        )
        max_output_tokens = self._parse_max_tokens(
            self._get_override_or_default(
                "max_output_tokens", OpenAIConfig.MAX_OUTPUT_TOKENS
            )
        )

        # Log which settings are using defaults vs overrides (simple format)
        self._log_voice_settings(
            voice_model=voice_model,
            voice=voice,
            turn_detection_mode=turn_detection_mode,
            transcription_model=transcription_model,
            noise_reduction_mode=noise_reduction_mode,
            max_output_tokens=max_output_tokens,
        )

        # Handle prompt modifications (override, append, prepend)
        instructions = self._build_instructions()

        session_config = self._build_session_config(
            voice=voice,
            turn_detection_mode=turn_detection_mode,
            transcription_model=transcription_model,
            noise_reduction_mode=noise_reduction_mode,
            max_output_tokens=max_output_tokens,
            instructions=instructions,
        )

        # Store runtime settings for per-session logging
        self._runtime_voice_settings = {
            "voice_model": voice_model,
            "voice": voice,
            "turn_detection_mode": turn_detection_mode,
            "transcription_model": transcription_model,
            "noise_reduction_mode": noise_reduction_mode,
            "max_output_tokens": max_output_tokens,
            "instructions_length": len(instructions),
            "instructions_preview": instructions[:100] + "..."
            if len(instructions) > 100
            else instructions,
        }

        return {
            "api_key": api_key,
            "websocket_url": websocket_url,
            "headers": [
                f"{Headers.AUTHORIZATION}: Bearer {api_key}",
                f"{Headers.OPENAI_BETA}: realtime=v1",
            ],
            "session_config": session_config,
            "connection_timeout": 10,
            "ping_interval": AudioConfig.PING_INTERVAL,
            "ping_timeout": AudioConfig.PING_TIMEOUT,
        }

    def _build_server_config(self) -> Dict[str, Any]:
        """Build server configuration"""
        return {
            "host": self._get_env_or_override("HOST", "0.0.0.0"),
            "port": int(self._get_env_or_override("PORT", "5000")),
            "debug": self._parse_bool(self._get_env_or_override("DEBUG", "False")),
            "secret_key": self._get_env_or_override("SECRET_KEY", "your-secret-key"),
            "cors_allowed_origins": self._get_env_or_override(
                "CORS_ALLOWED_ORIGINS", "*"
            ),
            "async_mode": self._get_env_or_override("ASYNC_MODE", "threading"),
        }

    def _build_audio_constraints(self) -> Dict[str, Any]:
        """Build audio processing constraints"""
        return {
            "min_duration_ms": AudioConfig.MIN_DURATION_MS,
            "max_size_bytes": 10 * 1024 * 1024,  # Maximum audio size (10MB)
            "min_size_bytes": 100,  # Minimum audio size
            "sample_rate": 24000,  # PCM16, 24kHz
            "channels": 1,  # Mono
            "bytes_per_sample": 2,  # PCM16 = 2 bytes per sample
            "supported_format": "pcm16",
        }

    def _build_instructions(self) -> str:
        """Build instructions with override, prepend, append support"""
        base_instructions = OpenAIConfig.INSTRUCTIONS
        instructions_config = self._config_overrides.get("instructions", {})

        if not isinstance(instructions_config, dict):
            logger.info(
                "instructions is not provided, using default (length: %d chars)",
                len(base_instructions),
            )
            return base_instructions

        # Override takes precedence (replaces entire prompt)
        if "override" in instructions_config:
            override_text = instructions_config["override"]
            logger.info(
                "instructions provided via override (length: %d chars, preview: %s)",
                len(override_text),
                override_text[:100] + "..."
                if len(override_text) > 100
                else override_text,
            )
            return override_text

        # Build final instructions with prepend and append
        final_instructions = base_instructions
        modified = False

        if "prepend" in instructions_config:
            prepend_text = instructions_config["prepend"]
            final_instructions = f"{prepend_text}\n\n{final_instructions}"
            logger.info(
                "instructions prepend provided (length: %d chars, preview: %s)",
                len(prepend_text),
                prepend_text[:100] + "..." if len(prepend_text) > 100 else prepend_text,
            )
            modified = True

        if "append" in instructions_config:
            append_text = instructions_config["append"]
            final_instructions = f"{final_instructions}\n\n{append_text}"
            logger.info(
                "instructions append provided (length: %d chars, preview: %s)",
                len(append_text),
                append_text[:100] + "..." if len(append_text) > 100 else append_text,
            )
            modified = True

        if not modified:
            logger.info(
                "instructions is not provided, using default (length: %d chars)",
                len(base_instructions),
            )
        else:
            logger.info(
                "instructions modified (final length: %d chars, preview: %s)",
                len(final_instructions),
                final_instructions[:100] + "..."
                if len(final_instructions) > 100
                else final_instructions,
            )

        return final_instructions

    def _build_session_config(
        self,
        *,
        voice: str,
        turn_detection_mode: str,
        transcription_model: str,
        noise_reduction_mode: str,
        max_output_tokens: Any,
        instructions: str,
    ) -> Dict[str, Any]:
        """Build OpenAI session configuration (matching realtime_api structure)"""
        # Build transcription config (matching realtime_api: {"model": "whisper-1"})
        transcription_config = {"model": transcription_model}
        # Only add noise_reduction if explicitly overridden (not in realtime_api by default)
        if "noise_reduction_mode" in self._config_overrides:
            transcription_config["noise_reduction"] = noise_reduction_mode

        # Auto-detect: if tools provided, enable function calling
        tools_list = self._config_overrides.get("tools", [])
        tool_choice = self._config_overrides.get(
            "tool_choice", "auto" if tools_list else "none"
        )

        # Log tools configuration
        if tools_list:
            logger.info(
                "tools provided via override (count: %d, tool_choice: %s)",
                len(tools_list),
                tool_choice,
            )
            # Log tool names for debugging
            tool_names = [
                tool.get("name", "unknown")
                for tool in tools_list
                if isinstance(tool, dict)
            ]
            if tool_names:
                logger.info("tool names: %s", ", ".join(tool_names))
        else:
            logger.info("tools is not provided, using default (none)")

        # Build turn detection config (support custom parameters like POC)
        turn_detection_config = OpenAIConfig.TURN_DETECTION_MAP.get(
            turn_detection_mode, None
        )
        # If turn_detection_mode is "normal" and custom params provided, merge them
        if (
            turn_detection_mode == "normal"
            and "turn_detection_params" in self._config_overrides
        ):
            custom_params = self._config_overrides["turn_detection_params"]
            if isinstance(custom_params, dict):
                turn_detection_config = {"type": "server_vad", **custom_params}

        return {
            "type": "session.update",
            "session": {
                "modalities": OpenAIConfig.MODALITIES,
                "instructions": instructions,  # Use modified instructions
                "voice": voice,
                "input_audio_format": "pcm16",
                "output_audio_format": "pcm16",
                "input_audio_transcription": transcription_config,  # Matching realtime_api
                "turn_detection": turn_detection_config,  # Can be None, basic, or with custom params
                "tools": tools_list,  # Use provided tools or empty list
                "tool_choice": tool_choice,  # Auto if tools provided, none otherwise
                "temperature": 0.6,  # Minimum required by OpenAI (matching realtime_api)
                "max_response_output_tokens": max_output_tokens,  # Matching realtime_api: "inf"
            },
        }

    def _parse_bool(self, value: str) -> bool:
        """Parse string to boolean"""
        return value.lower() in ("true", "1", "yes", "on")

    def get_session_config_json(self) -> str:
        """Get session configuration as JSON string"""
        return json.dumps(self._openai_config["session_config"])

    def get_runtime_voice_settings(self) -> Dict[str, Any]:
        """Expose resolved runtime voice settings"""
        return deepcopy(self._runtime_voice_settings)

    def validate_configuration(self) -> Dict[str, Any]:
        """Validate all configurations and return validation results"""
        errors = []
        warnings = []

        # Validate OpenAI config
        if not self._openai_config.get("api_key"):
            errors.append("OpenAI API key is missing")

        # Validate server config
        port = self._server_config.get("port")
        if not isinstance(port, int) or port < 1 or port > 65535:
            errors.append(f"Invalid port number: {port}")

        # Validate audio constraints
        min_duration = self._audio_constraints.get("min_duration_ms")
        if not isinstance(min_duration, (int, float)) or min_duration <= 0:
            errors.append(f"Invalid minimum audio duration: {min_duration}")

        return {"valid": len(errors) == 0, "errors": errors, "warnings": warnings}

    def _normalize_turn_detection_mode(self, mode: Optional[str]) -> str:
        if not mode:
            return OpenAIConfig.TURN_DETECTION_MODE
        normalized = str(mode).lower()
        if normalized not in OpenAIConfig.TURN_DETECTION_MAP:
            return OpenAIConfig.TURN_DETECTION_MODE
        return normalized

    def _normalize_noise_reduction_mode(self, mode: Optional[str]) -> str:
        if not mode:
            return OpenAIConfig.NOISE_REDUCTION_MODE
        normalized = str(mode).lower()
        if normalized not in OpenAIConfig.NOISE_REDUCTION_OPTIONS:
            return OpenAIConfig.NOISE_REDUCTION_MODE
        return normalized

    def _parse_max_tokens(self, value: Any) -> Any:
        if value == "inf":
            return "inf"
        if isinstance(value, str):
            if value.strip().lower() in {"inf", "infinite", "unlimited"}:
                return "inf"
            if value.isdigit():
                parsed = int(value)
                return parsed if parsed > 0 else OpenAIConfig.MAX_OUTPUT_TOKENS
        if isinstance(value, (int, float)):
            parsed = int(value)
            return parsed if parsed > 0 else OpenAIConfig.MAX_OUTPUT_TOKENS
        return OpenAIConfig.MAX_OUTPUT_TOKENS

    def _log_voice_settings(
        self,
        voice_model: str,
        voice: str,
        turn_detection_mode: str,
        transcription_model: str,
        noise_reduction_mode: str,
        max_output_tokens: str,
    ) -> None:
        """Log voice settings in simple format"""
        if "voice_model" not in self._config_overrides:
            logger.info("voice_model is not provided, using default (%s)", voice_model)
        else:
            logger.info("voice_model provided via override (%s)", voice_model)

        if "voice" not in self._config_overrides:
            logger.info("voice is not provided, using default (%s)", voice)
        else:
            logger.info("voice provided via override (%s)", voice)

        if "turn_detection_mode" not in self._config_overrides:
            logger.info(
                "turn_detection_mode is not provided, using default (%s)",
                turn_detection_mode,
            )
        else:
            logger.info(
                "turn_detection_mode provided via override (%s)", turn_detection_mode
            )

        if "transcription_model" not in self._config_overrides:
            logger.info(
                "transcription_model is not provided, using default (%s)",
                transcription_model,
            )
        else:
            logger.info(
                "transcription_model provided via override (%s)", transcription_model
            )

        # Only log noise_reduction if explicitly overridden (not in realtime_api by default)
        if "noise_reduction_mode" in self._config_overrides:
            logger.info(
                "noise_reduction_mode provided via override (%s)", noise_reduction_mode
            )

        if "max_output_tokens" not in self._config_overrides:
            logger.info(
                "max_output_tokens is not provided, using default (%s)",
                max_output_tokens,
            )
        else:
            logger.info(
                "max_output_tokens provided via override (%s)", max_output_tokens
            )
