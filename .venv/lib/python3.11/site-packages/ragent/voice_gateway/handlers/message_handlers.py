"""
Message handlers for OpenAI Realtime API messages
"""

import asyncio
import json
import logging
import time
from abc import ABC, abstractmethod
from typing import Any, Callable, Dict, Optional

from ragent.voice_gateway.config.constants import (
    Messages,
    OpenAIMessageTypes,
    SocketEvents,
)
from ragent.voice_gateway.domain.async_task_queue import TaskQueueManager
from ragent.voice_gateway.domain.commands import CommandFactory
from ragent.voice_gateway.domain.domain_services import DomainServiceFactory
from ragent.voice_gateway.infrastructure.services import (
    EventEmitterService,
    IWebSocketService,
)

logger = logging.getLogger(__name__)


class MessageHandlerContext:
    """Focused context with only required dependencies"""

    def __init__(
        self,
        command_factory: Optional[CommandFactory],
        domain_service_factory: DomainServiceFactory,
        event_emitter: EventEmitterService,
        websocket_service: Optional[IWebSocketService] = None,
        function_map: Optional[Dict[str, Callable]] = None,
    ):
        self.command_factory = command_factory
        self.domain_service_factory = domain_service_factory
        self.event_emitter = event_emitter
        self.websocket_service = websocket_service
        self.function_map = function_map or {}


class ImprovedMessageHandler(ABC):
    """Abstract base class for message handlers"""

    def __init__(self, context: MessageHandlerContext):
        self._context = context

    @abstractmethod
    async def handle(self, response: Dict[str, Any], client_id: str) -> None:
        """Handle the specific message type asynchronously"""
        pass


class ImprovedTranscriptionCompletedHandler(ImprovedMessageHandler):
    """Handler for transcription completed messages"""

    async def handle(self, response: Dict[str, Any], client_id: str) -> None:
        transcript = response.get("transcript", "")

        if transcript.strip():
            # Skip agent callback if in function calling mode (no command_factory)
            if not self._context.command_factory:
                # In function calling mode, model handles everything - no agent callback
                # The model will automatically respond based on the transcript
                logger.info(
                    "[%s] Transcript received in function calling mode: '%s' (model will respond automatically)",
                    client_id,
                    transcript,
                )
                # Emit event for debugging
                self._context.event_emitter.emit_to_client(
                    client_id,
                    "transcript_received",
                    {
                        "transcript": transcript,
                        "mode": "function_calling",
                        "message": "Model will process and respond automatically",
                    },
                )
                # Explicitly trigger model to respond (or call function)
                # No delay - Realtime API is designed for low latency
                if self._context.websocket_service:
                    response_create = {"type": "response.create"}
                    self._context.websocket_service.send_message(
                        client_id, response_create
                    )
                    logger.info(
                        "[%s] Triggered response.create for function calling mode",
                        client_id,
                    )
                else:
                    logger.error(
                        "[%s] WebSocket service not available to trigger response",
                        client_id,
                    )
                return

            try:
                # Create command using factory
                command = self._context.command_factory.create_composite_command(
                    client_id, transcript.strip()
                )

                # Get task queue and enqueue command
                task_queue = await TaskQueueManager.get_instance()
                success = await task_queue.enqueue_command(command)

                if not success:
                    self._context.event_emitter.emit_to_client(
                        client_id,
                        SocketEvents.ERROR,
                        {"message": "Failed to process transcript - queue full"},
                    )

            except Exception as e:
                self._context.event_emitter.emit_to_client(
                    client_id,
                    SocketEvents.ERROR,
                    {"message": f"Transcript processing error: {str(e)}"},
                )


class ImprovedResponseAudioDeltaHandler(ImprovedMessageHandler):
    """Handler for response audio delta messages"""

    def __init__(self, context: MessageHandlerContext):
        super().__init__(context)
        self._chunk_counters: Dict[str, int] = {}  # Track chunk index per client

    async def handle(self, response: Dict[str, Any], client_id: str) -> None:
        audio_data = response.get("delta", "")
        if audio_data:
            # Track chunk index
            if client_id not in self._chunk_counters:
                self._chunk_counters[client_id] = 0
            else:
                self._chunk_counters[client_id] += 1

            # Send audio directly to client
            self._context.event_emitter.emit_to_client(
                client_id,
                SocketEvents.RESPONSE_AUDIO,
                {
                    "audio": audio_data,
                    "chunk_index": self._chunk_counters[client_id],
                    "timestamp": time.time(),
                },
            )


class ImprovedResponseDoneHandler(ImprovedMessageHandler):
    """Handler for response done messages"""

    async def handle(self, response: Dict[str, Any], client_id: str) -> None:
        response_id = response.get("response", {}).get("id", "unknown")

        # Send completion event to client
        self._context.event_emitter.emit_to_client(
            client_id,
            SocketEvents.RESPONSE_DONE,
            {
                "response_id": response_id,
                "status": "completed",
                "timestamp": time.time(),
            },
        )

        # Clear chunk counter for this client
        if hasattr(self._context, "audio_delta_handler"):
            handler = self._context.audio_delta_handler
            if (
                hasattr(handler, "_chunk_counters")
                and client_id in handler._chunk_counters
            ):
                del handler._chunk_counters[client_id]


class ImprovedErrorHandler(ImprovedMessageHandler):
    """Handler for error messages"""

    async def handle(self, response: Dict[str, Any], client_id: str) -> None:
        error_details = response.get("error", {})
        error_message = error_details.get("message", "Unknown error")
        error_code = error_details.get("code", "unknown")

        # Send error to client
        self._context.event_emitter.emit_to_client(
            client_id,
            SocketEvents.ERROR,
            {
                "message": f"{Messages.OPENAI_ERROR}: {error_message}",
                "code": error_code,
                "timestamp": time.time(),
            },
        )


class FunctionCallHandler(ImprovedMessageHandler):
    """Handler for function calls - EXECUTES IMMEDIATELY (no queue for low latency)"""

    async def handle(self, response: Dict[str, Any], client_id: str) -> None:
        """Handle function call event - immediate execution"""
        try:
            call_id = response.get("call_id")
            name = response.get("name")
            arguments_str = response.get("arguments", "{}")

            if not call_id or not name:
                logger.warning(
                    "[%s] Invalid function call event: missing call_id or name",
                    client_id,
                )
                return

            # Parse arguments
            try:
                arguments = json.loads(arguments_str)
            except json.JSONDecodeError as e:
                logger.error(
                    "[%s] Failed to parse function arguments: %s",
                    client_id,
                    str(e),
                    exc_info=True,
                )
                return

            logger.info(
                "[%s] Function call: %s with args: %s", client_id, name, arguments
            )

            # Execute function IMMEDIATELY (synchronous, no queue)
            if name not in self._context.function_map:
                logger.error(
                    "[%s] Function '%s' not found in function_map", client_id, name
                )
                return

            function = self._context.function_map[name]
            try:
                # Execute function (sync or async)
                if asyncio.iscoroutinefunction(function):
                    result = await function(**arguments)
                else:
                    result = function(**arguments)
            except Exception as e:
                logger.error(
                    "[%s] Error executing function '%s': %s",
                    client_id,
                    name,
                    str(e),
                    exc_info=True,
                )
                result = {"error": str(e), "success": False}

            # Send result back IMMEDIATELY (no queue)
            function_output = {
                "type": "conversation.item.create",
                "item": {
                    "type": "function_call_output",
                    "call_id": call_id,
                    "output": json.dumps(result)
                    if isinstance(result, dict)
                    else str(result),
                },
            }

            if self._context.websocket_service:
                self._context.websocket_service.send_message(client_id, function_output)

                # Trigger response immediately to continue conversation
                response_create = {"type": "response.create"}
                self._context.websocket_service.send_message(client_id, response_create)

                logger.info("[%s] Function result sent: %s", client_id, result)
            else:
                logger.error(
                    "[%s] WebSocket service not available for function call",
                    client_id,
                )

        except Exception as e:
            logger.error(
                "[%s] Error handling function call: %s",
                client_id,
                str(e),
                exc_info=True,
            )


class ImprovedOpenAIMessageHandlerFactory:
    """Factory for creating message handlers"""

    def __init__(self, context: MessageHandlerContext):
        self._context = context
        # Create shared audio delta handler for chunk tracking
        audio_delta_handler = ImprovedResponseAudioDeltaHandler(context)
        context.audio_delta_handler = audio_delta_handler  # Store reference for cleanup

        self._handlers = {
            OpenAIMessageTypes.CONVERSATION_ITEM_INPUT_AUDIO_TRANSCRIPTION_COMPLETED: ImprovedTranscriptionCompletedHandler(
                context
            ),
            OpenAIMessageTypes.RESPONSE_AUDIO_DELTA: audio_delta_handler,
            OpenAIMessageTypes.RESPONSE_DONE: ImprovedResponseDoneHandler(context),
            OpenAIMessageTypes.ERROR: ImprovedErrorHandler(context),
        }

        # Add function call handler only if function_map is provided (function calling mode)
        if context.function_map:
            self._handlers[
                OpenAIMessageTypes.RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE
            ] = FunctionCallHandler(context)

    async def handle_message(self, message: str, client_id: str) -> None:
        """Handle an OpenAI message"""
        try:
            response = json.loads(message)
            message_type = response.get("type")

            if message_type in self._handlers:
                await self._handlers[message_type].handle(response, client_id)
            else:
                # Log unhandled message types for debugging
                if self._context.function_map:
                    logger.debug(
                        "[%s] Unhandled message type: %s (payload: %s)",
                        client_id,
                        message_type,
                        str(response)[:200],  # First 200 chars
                    )
        except (json.JSONDecodeError, KeyError) as e:
            logger.error(
                "[%s] Error parsing OpenAI message: %s",
                client_id,
                str(e),
                exc_info=True,
            )
        except Exception as e:
            logger.error(
                "[%s] Unexpected error handling message: %s",
                client_id,
                str(e),
                exc_info=True,
            )
