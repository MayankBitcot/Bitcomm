"""
Voice Handler - Lightweight facade for voice-to-voice interactions
"""

import asyncio
import logging
import threading
import time
from typing import Any, Callable, Dict, Optional

from ragent.voice_gateway.config.config import ConfigService
from ragent.voice_gateway.config.constants import SocketEvents
from ragent.voice_gateway.domain.commands import CommandFactory
from ragent.voice_gateway.domain.domain_services import DomainServiceFactory
from ragent.voice_gateway.handlers.message_handlers import (
    ImprovedOpenAIMessageHandlerFactory,
    MessageHandlerContext,
)
from ragent.voice_gateway.infrastructure.services import (
    AudioService,
    EventEmitterService,
    SessionService,
    WebSocketService,
)
from ragent.voice_gateway.utils.exceptions import (
    AudioProcessingError,
    AudioValidationError,
    ConfigurationError,
    SessionError,
    WebSocketConnectionError,
)

logger = logging.getLogger(__name__)


class VoiceHandler:
    """Lightweight facade for voice-to-voice interactions using OpenAI Realtime API"""

    def __init__(
        self,
        config_service: ConfigService,
        on_transcript_callback: Optional[Callable] = None,
        callback_timeout: int = 120,
        function_map: Optional[Dict[str, Callable]] = None,
    ):
        """Initialize VoiceHandler with dependency injection"""
        try:
            self._config_service = config_service
            self._on_transcript_callback = on_transcript_callback
            self._callback_timeout = callback_timeout
            self._function_map = function_map or {}

            # Validate configuration
            validation_result = self._config_service.validate_configuration()
            if not validation_result["valid"]:
                raise ConfigurationError(
                    "Invalid configuration",
                    config_section="validation",
                )

            # Initialize core services
            self._audio_service = AudioService(self._config_service)
            self._session_service = SessionService()
            self._websocket_service = WebSocketService(self._config_service)
            self._event_emitter = EventEmitterService()

            # Initialize domain service factory
            self._domain_service_factory = DomainServiceFactory(
                self._audio_service,
                self._session_service,
                self._websocket_service,
                self._event_emitter,
                self._config_service,
                self._on_transcript_callback,
                self._callback_timeout,
            )

            # Create specialized domain services
            self._audio_management = (
                self._domain_service_factory.create_audio_management_service()
            )
            # Only create conversation orchestrator if agent callback is provided
            if self._on_transcript_callback:
                self._conversation_orchestrator = (
                    self._domain_service_factory.create_conversation_orchestrator()
                )
            else:
                self._conversation_orchestrator = None
            self._tts_service = self._domain_service_factory.create_tts_service()

            # Initialize command factory (only if orchestrator exists)
            if self._conversation_orchestrator:
                self._command_factory = CommandFactory(
                    self._conversation_orchestrator, self._tts_service
                )
            else:
                # Create a minimal command factory for function calling mode
                self._command_factory = None

            # Initialize message handlers
            # For function calling mode, command_factory may be None
            handler_context = MessageHandlerContext(
                command_factory=self._command_factory,
                domain_service_factory=self._domain_service_factory,
                event_emitter=self._event_emitter,
                websocket_service=self._websocket_service,
                function_map=self._function_map,
            )
            self._message_handler_factory = ImprovedOpenAIMessageHandlerFactory(
                handler_context
            )

        except Exception:
            raise ConfigurationError(
                "VoiceHandler initialization failed", config_section="init"
            )

    def set_event_emitter(self, socketio_instance):
        """Set the SocketIO instance for event emission"""
        self._event_emitter.set_socketio_instance(socketio_instance)

    def start_session(
        self,
        client_id: str,
        emit_callback: Callable,
        chat_payload: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Start a new voice session for a client"""
        try:
            # Use default payload if none provided
            if chat_payload is None:
                chat_payload = self._create_default_chat_payload()

            # Create session
            result = self._session_service.create_session(client_id, chat_payload)

            # Store emit callback in session
            self._session_service.update_session(
                client_id, {"emit_callback": emit_callback}
            )

            # Start WebSocket connection in background thread
            connection_thread = threading.Thread(
                target=self._establish_websocket_connection,
                args=(client_id,),
                daemon=True,
            )
            connection_thread.start()

            return result

        except Exception as e:
            raise SessionError(f"Failed to start session: {str(e)}", client_id)

    def handle_audio_data(self, client_id: str, audio_data: str) -> None:
        """Handle incoming audio data from client"""
        try:
            self._audio_management.validate_and_accumulate(client_id, audio_data)
        except (
            AudioValidationError,
            SessionError,
            WebSocketConnectionError,
        ) as e:
            self._emit_error_to_client(client_id, str(e))
            raise
        except Exception as e:
            error = AudioProcessingError(f"Audio processing error: {str(e)}", client_id)
            self._emit_error_to_client(client_id, str(error))
            raise error

    def commit_audio(self, client_id: str) -> None:
        """Commit accumulated audio for processing"""
        try:
            self._audio_management.commit_accumulated_audio(client_id)
        except (SessionError, AudioProcessingError, WebSocketConnectionError) as e:
            self._emit_error_to_client(client_id, str(e))
            raise
        except Exception as e:
            error = AudioProcessingError(f"Commit error: {str(e)}", client_id)
            self._emit_error_to_client(client_id, str(error))
            raise error

    def end_session(self, client_id: str) -> Dict[str, Any]:
        """End voice session for a client"""
        try:
            # Disconnect WebSocket
            if self._websocket_service.is_connected(client_id):
                self._websocket_service.disconnect(client_id)

            # End session
            result = self._session_service.end_session(client_id)
            return result

        except Exception as e:
            return {
                "status": "error",
                "message": f"Failed to end session: {str(e)}",
                "client_id": client_id,
            }

    def _establish_websocket_connection(self, client_id: str) -> None:
        """Establish WebSocket connection with OpenAI"""
        try:

            def on_message(message):
                try:
                    threading.Thread(
                        target=self._handle_message_sync,
                        args=(message, client_id),
                        daemon=True,
                    ).start()
                except Exception as e:
                    self._emit_error_to_client(
                        client_id, f"Message processing error: {str(e)}"
                    )

            def on_error(error):
                self._emit_error_to_client(client_id, f"Connection error: {error}")

            def on_close():
                self._session_service.update_session(
                    client_id, {"websocket_connected": False}
                )

            # Connect using WebSocket service
            success = self._websocket_service.connect(
                client_id, on_message, on_error, on_close
            )

            if success:
                # Update session status
                self._session_service.update_session(
                    client_id, {"websocket_connected": True}
                )

                # Emit session_started event
                self._event_emitter.emit_to_client(
                    client_id,
                    SocketEvents.SESSION_STARTED,
                    {
                        "status": "session_started",
                        "session_id": client_id,
                        "message": "Session is ready to receive audio",
                        "timestamp": time.time(),
                    },
                )

                # In function calling mode, trigger initial greeting (like POC)
                if self._function_map and not self._on_transcript_callback:
                    # Use threading to avoid blocking
                    def trigger_greeting():
                        import time as time_module

                        # Small delay to ensure session is ready
                        time_module.sleep(0.5)
                        try:
                            greeting_event = {
                                "type": "response.create",
                                "response": {
                                    "modalities": ["text", "audio"],
                                },
                            }
                            self._websocket_service.send_message(
                                client_id, greeting_event
                            )
                            logger.info(
                                "[%s] Initial greeting triggered for function calling mode",
                                client_id,
                            )
                        except Exception as e:
                            logger.error(
                                "[%s] Failed to trigger initial greeting: %s",
                                client_id,
                                str(e),
                                exc_info=True,
                            )

                    # Trigger greeting in background thread
                    greeting_thread = threading.Thread(
                        target=trigger_greeting, daemon=True
                    )
                    greeting_thread.start()
            else:
                raise WebSocketConnectionError(
                    "Failed to establish WebSocket connection", client_id
                )

        except Exception as e:
            self._emit_error_to_client(client_id, f"Connection failed: {str(e)}")

    def _handle_message_sync(self, message: str, client_id: str) -> None:
        """Handle OpenAI message synchronously by creating new event loop"""
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(self._handle_openai_message(message, client_id))
        except Exception as e:
            self._emit_error_to_client(client_id, f"Message handling error: {str(e)}")
        finally:
            try:
                loop.close()
            except Exception:
                pass

    async def _handle_openai_message(self, message: str, client_id: str) -> None:
        """Handle OpenAI message using improved message handlers"""
        try:
            await self._message_handler_factory.handle_message(message, client_id)
        except Exception as e:
            self._emit_error_to_client(client_id, f"Message handling error: {str(e)}")

    def _create_default_chat_payload(self) -> Dict[str, Any]:
        """Create default chat payload"""
        return {
            "contextId": None,
            "kind": "message",
            "messageId": str(time.time()),
            "taskId": str(time.time()),
            "metadata": {
                "message_log": [],
            },
            "parts": [{"kind": "text", "text": ""}],
            "referenceTaskIds": [],
            "role": "user",
        }

    def _emit_error_to_client(self, client_id: str, message: str) -> None:
        """Emit error message to client"""
        try:
            self._event_emitter.emit_to_client(
                client_id, SocketEvents.ERROR, {"message": message}
            )
        except Exception:
            pass

    def get_health_status(self) -> Dict[str, Any]:
        """Get comprehensive health status of all services"""
        try:
            config_validation = self._config_service.validate_configuration()
            return {
                "status": "healthy" if config_validation["valid"] else "unhealthy",
                "config_valid": config_validation["valid"],
                "services": {
                    "audio_service": "available",
                    "session_service": "available",
                    "websocket_service": "available",
                    "conversation_orchestrator": "available",
                    "tts_service": "available",
                },
                "timestamp": time.time(),
            }
        except Exception as e:
            return {
                "status": "unhealthy",
                "error": str(e),
                "timestamp": time.time(),
            }
