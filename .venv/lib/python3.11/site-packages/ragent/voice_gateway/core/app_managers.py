"""
App Managers for Voice Gateway - Routes and Event Handlers
"""

import asyncio
import time
from typing import Any, Callable, Dict

from ragent.voice_gateway.config.constants import (
    Messages,
    ServiceNames,
    SessionStatus,
    SocketEvents,
)
from ragent.voice_gateway.domain.async_task_queue import TaskQueueManager


class RoutesManager:
    """Manages HTTP routes for the Voice Gateway"""

    def __init__(self, voice_handler, config_service):
        self._voice_handler = voice_handler
        self._config_service = config_service

    def register_routes(self, app):
        """Register all HTTP routes"""

        @app.route("/health")
        def health_check():
            """Health check endpoint"""
            try:
                health_status = self._voice_handler.get_health_status()
                health_status.update(
                    {
                        "service": ServiceNames.VOICE_GATEWAY,
                        "timestamp": time.time(),
                    }
                )
                status_code = 200 if health_status["status"] == "healthy" else 500
                return health_status, status_code
            except Exception as e:
                return {
                    "status": Messages.HEALTH_STATUS_UNHEALTHY,
                    "service": ServiceNames.VOICE_GATEWAY,
                    "error": str(e),
                    "timestamp": time.time(),
                }, 500


class EventHandlersManager:
    """Manages SocketIO event handlers for the Voice Gateway"""

    def __init__(self, voice_handler, websocket_handler):
        self._voice_handler = voice_handler
        self._websocket = websocket_handler

    def register_event_handlers(self):
        """Register all SocketIO event handlers with framework-agnostic signatures"""

        # Create wrapper functions that accept flexible arguments for any Socket.IO implementation
        # Flask-SocketIO: connect() - no args
        # python-socketio (async): connect(sid, environ) - requires sid
        # Django/Tornado/Sanic/Aiohttp: may have different signatures

        def connect_wrapper(*args, **kwargs):
            return self._handle_connect(self._get_client_id())

        def disconnect_wrapper(*args, **kwargs):
            return self._handle_disconnect(self._get_client_id())

        def start_session_wrapper(data=None, *args, **kwargs):
            return self._handle_start_session(self._get_client_id(), data)

        def audio_data_wrapper(data, *args, **kwargs):
            return self._handle_audio_data(self._get_client_id(), data)

        def commit_audio_wrapper(*args, **kwargs):
            return self._handle_commit_audio(self._get_client_id())

        def end_session_wrapper(*args, **kwargs):
            return self._handle_end_session(self._get_client_id())

        def ping_wrapper(*args, **kwargs):
            return self._handle_ping()

        def error_wrapper(e, *args, **kwargs):
            return self._handle_error(e)

        self._websocket.on("connect", connect_wrapper)
        self._websocket.on("disconnect", disconnect_wrapper)
        self._websocket.on("start_session", start_session_wrapper)
        self._websocket.on("audio_data", audio_data_wrapper)
        self._websocket.on("commit_audio", commit_audio_wrapper)
        self._websocket.on("end_session", end_session_wrapper)
        self._websocket.on("ping", ping_wrapper)
        self._websocket.on_error(error_wrapper)

    def _get_client_id(self) -> str:
        """Get the current client ID from the websocket context"""
        # Delegate to the websocket handler to get the current client ID
        # For Flask-SocketIO, this would access request.sid
        return self._websocket.get_current_client_id()

    def _handle_connect(self, client_id: str):
        """Handle client connection"""
        self._websocket.emit(
            SocketEvents.CONNECTION_ESTABLISHED,
            {
                "client_id": client_id,
                "message": Messages.CONNECTION_ESTABLISHED,
                "timestamp": time.time(),
            },
        )

    def _handle_disconnect(self, client_id: str):
        """Handle client disconnection"""
        try:
            self._voice_handler.end_session(client_id)
        except Exception:
            pass

    def _handle_start_session(self, client_id: str, data=None):
        """Start a new voice session"""
        try:
            emit_callback = self._create_emit_callback(client_id)
            chat_payload = data if isinstance(data, dict) else None
            result = self._voice_handler.start_session(
                client_id, emit_callback, chat_payload
            )
            self._process_session_start_result(client_id, result)
        except Exception as e:
            self._websocket.emit(
                SocketEvents.ERROR,
                {
                    "message": f"Session start failed: {str(e)}",
                    "timestamp": time.time(),
                },
            )

    def _handle_audio_data(self, client_id: str, data):
        """Handle incoming audio data"""
        try:
            if not data or "audio" not in data:
                self._websocket.emit(
                    SocketEvents.ERROR, {"message": "Invalid audio data format"}
                )
                return

            audio_data = data["audio"]
            self._voice_handler.handle_audio_data(client_id, audio_data)
        except Exception as e:
            self._websocket.emit(
                SocketEvents.ERROR,
                {
                    "message": f"Audio processing failed: {str(e)}",
                    "timestamp": time.time(),
                },
            )

    def _handle_commit_audio(self, client_id: str):
        """Commit accumulated audio for processing"""
        try:
            self._voice_handler.commit_audio(client_id)
            self._websocket.emit(
                SocketEvents.AUDIO_COMMITTED,
                {
                    "message": "Audio committed for processing",
                    "timestamp": time.time(),
                },
            )
        except Exception as e:
            self._websocket.emit(
                SocketEvents.ERROR,
                {
                    "message": f"Audio commit failed: {str(e)}",
                    "timestamp": time.time(),
                },
            )

    def _handle_end_session(self, client_id: str):
        """End the voice session"""
        try:
            result = self._voice_handler.end_session(client_id)
            self._websocket.emit(SocketEvents.SESSION_ENDED, result)
        except Exception as e:
            self._websocket.emit(
                SocketEvents.ERROR,
                {
                    "message": f"Session end failed: {str(e)}",
                    "timestamp": time.time(),
                },
            )

    def _handle_ping(self):
        """Handle ping for connection testing"""
        self._websocket.emit("pong", {"timestamp": time.time()})

    def _handle_error(self, e):
        """Handle SocketIO errors"""
        pass

    def _create_emit_callback(self, client_id: str) -> Callable:
        """Create emit callback with proper context"""

        def emit_callback(event, data_to_emit, room=None):
            try:
                target_room = room or client_id
                self._websocket.emit(event, data_to_emit, to=target_room)
            except Exception:
                pass

        return emit_callback

    def _process_session_start_result(self, client_id: str, result: Dict[str, Any]):
        """Process the result of session start"""
        success_statuses = [SessionStatus.STARTING, SessionStatus.CREATED]
        status = result.get("status")
        if status in success_statuses:
            event_name = (
                SocketEvents.SESSION_STARTING
                if status == SessionStatus.STARTING
                else SocketEvents.SESSION_CREATED
            )
            self._websocket.emit(event_name, result, to=client_id)
        else:
            self._websocket.emit(SocketEvents.ERROR, result, to=client_id)


class ApplicationOrchestrator:
    """Main application orchestrator"""

    def __init__(self, app, websocket_handler, voice_handler, config_service):
        self._app = app
        self._websocket = websocket_handler
        self._voice_handler = voice_handler
        self._config_service = config_service

        # Initialize managers
        self._routes_manager = RoutesManager(voice_handler, config_service)
        self._events_manager = EventHandlersManager(voice_handler, websocket_handler)

    def initialize(self):
        """Initialize the application components"""
        try:
            # Register routes and event handlers
            self._routes_manager.register_routes(self._app)
            self._events_manager.register_event_handlers()

            # Initialize async task queue
            self._initialize_task_queue()

        except Exception as e:
            raise RuntimeError(f"Application initialization failed: {str(e)}") from e

    def _initialize_task_queue(self):
        """Initialize the async task queue in a background thread"""
        import threading

        def run_queue_loop():
            try:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)

                async def setup_and_run_queue():
                    await TaskQueueManager.get_instance(max_workers=3)
                    while True:
                        await asyncio.sleep(1)

                loop.run_until_complete(setup_and_run_queue())

            except Exception:
                pass

        queue_thread = threading.Thread(target=run_queue_loop, daemon=True)
        queue_thread.start()

    def run(self, host: str = "0.0.0.0", port: int = 5000, debug: bool = False):
        """Run the application"""
        try:
            # Delegate to the app's run method
            self._app.run(host=host, port=port, debug=debug)
        except Exception as e:
            raise RuntimeError(f"Application failed to start: {str(e)}") from e

    def shutdown(self):
        """Shutdown the application gracefully"""
        try:
            import asyncio

            async def shutdown_queue():
                await TaskQueueManager.shutdown()

            try:
                loop = asyncio.get_event_loop()
            except RuntimeError:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)

            loop.run_until_complete(shutdown_queue())

        except Exception:
            pass

    def get_health_status(self) -> Dict[str, Any]:
        """Get application health status"""
        try:
            voice_handler_health = self._voice_handler.get_health_status()
            return {
                "application": "healthy",
                "voice_handler": voice_handler_health,
                "components": {
                    "routes_manager": "active",
                    "events_manager": "active",
                    "task_queue": "active"
                    if TaskQueueManager.is_initialized()
                    else "inactive",
                },
                "timestamp": time.time(),
            }
        except Exception as e:
            return {
                "application": "unhealthy",
                "error": str(e),
                "timestamp": time.time(),
            }
