"""
Async Helper Utilities

This module provides utilities for handling both sync and async operations,
allowing ragent.voice_gateway to work seamlessly with both Flask-SocketIO (sync)
and python-socketio AsyncServer (async).
"""
import asyncio
import inspect
from typing import Callable


def safe_emit(emit_func: Callable, *args, **kwargs) -> None:
    """
    Safely call emit function whether it's sync or async.

    This allows ragent to work with both Flask-SocketIO (sync)
    and python-socketio AsyncServer (async) without knowing which one is used.

    Args:
        emit_func: The emit function (can be sync or async)
        *args: Positional arguments for emit
        **kwargs: Keyword arguments for emit

    Example:
        # Works with Flask-SocketIO (sync)
        safe_emit(socketio.emit, 'event', {'data': 'value'}, to=client_id)

        # Works with python-socketio (async)
        safe_emit(sio.emit, 'event', {'data': 'value'}, room=client_id)
    """
    result = emit_func(*args, **kwargs)

    # If it's a coroutine, handle it asynchronously
    if inspect.iscoroutine(result):
        try:
            # Try to get running loop
            loop = asyncio.get_running_loop()

            # Create task to run in background
            task = loop.create_task(result)

            # Store task reference to prevent garbage collection
            # This is CRITICAL for async emit to work properly
            if not hasattr(loop, "_ragent_tasks"):
                loop._ragent_tasks = set()

            loop._ragent_tasks.add(task)

            # Remove task from set when done (cleanup)
            task.add_done_callback(loop._ragent_tasks.discard)

        except RuntimeError:
            # No loop running, create one and run
            try:
                asyncio.run(result)
            except Exception:
                # If that fails too, silently handle
                pass

    # If sync, it already completed, nothing to do
    return None


async def async_safe_emit(emit_func: Callable, *args, **kwargs) -> None:
    """
    Async version of safe_emit - await if coroutine, call if sync.

    Use this when you're already in an async context and want to ensure
    the emit completes before continuing.

    Args:
        emit_func: The emit function (can be sync or async)
        *args: Positional arguments for emit
        **kwargs: Keyword arguments for emit

    Example:
        # In an async function
        await async_safe_emit(socketio.emit, 'event', {'data': 'value'})
    """
    result = emit_func(*args, **kwargs)

    if inspect.iscoroutine(result):
        await result
    # If sync, it already completed


def is_async_callable(func: Callable) -> bool:
    """
    Check if a callable is async (coroutine function).

    Args:
        func: The callable to check

    Returns:
        True if async, False if sync
    """
    return inspect.iscoroutinefunction(func)


def get_or_create_event_loop() -> asyncio.AbstractEventLoop:
    """
    Get the current event loop or create a new one if none exists.

    Returns:
        The event loop
    """
    try:
        return asyncio.get_running_loop()
    except RuntimeError:
        try:
            return asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            return loop
