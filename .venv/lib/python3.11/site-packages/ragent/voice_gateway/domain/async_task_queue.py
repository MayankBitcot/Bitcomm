"""
Async Task Queue implementation for Voice Package
"""

import asyncio
import time
from asyncio import Queue
from typing import Any, Dict, List, Optional

from ragent.voice_gateway.domain.commands import IAsyncCommand


class AsyncTaskQueue:
    """Async task queue for managing command execution"""

    def __init__(self, max_workers: int = 3, max_queue_size: int = 100):
        self._max_workers = max_workers
        self._max_queue_size = max_queue_size
        self._queue: Queue[IAsyncCommand] = Queue(maxsize=max_queue_size)
        self._workers: List[asyncio.Task] = []
        self._is_running = False
        self._processed_commands = 0
        self._failed_commands = 0
        self._start_time = time.time()

    async def start(self) -> None:
        """Start the task queue workers"""
        if self._is_running:
            return

        self._is_running = True

        # Create worker tasks
        for _ in range(self._max_workers):
            worker = asyncio.create_task(self._worker())
            self._workers.append(worker)

    async def stop(self) -> None:
        """Stop the task queue workers gracefully"""
        if not self._is_running:
            return

        self._is_running = False

        # Cancel all worker tasks
        for worker in self._workers:
            worker.cancel()

        # Wait for workers to finish
        await asyncio.gather(*self._workers, return_exceptions=True)

        self._workers.clear()

    async def enqueue_command(self, command: IAsyncCommand) -> bool:
        """Enqueue a command for async execution"""
        if not self._is_running:
            raise RuntimeError("Task queue is not running. Call start() first.")

        if not command.can_execute():
            return False

        try:
            await asyncio.wait_for(self._queue.put(command), timeout=1.0)
            return True

        except Exception:
            return False

    async def _worker(self) -> None:
        """Worker coroutine that processes commands from the queue"""
        while self._is_running:
            try:
                command = await asyncio.wait_for(self._queue.get(), timeout=1.0)
                await self._execute_command(command)
                self._queue.task_done()

            except asyncio.TimeoutError:
                continue

            except asyncio.CancelledError:
                break

            except Exception:
                pass

    async def _execute_command(self, command: IAsyncCommand) -> None:
        """Execute a command and handle results/errors"""
        try:
            if not command.can_execute():
                return

            await command.execute()
            self._processed_commands += 1

        except Exception:
            self._failed_commands += 1

    def get_statistics(self) -> Dict[str, Any]:
        """Get queue statistics"""
        uptime = time.time() - self._start_time
        return {
            "is_running": self._is_running,
            "queue_size": self._queue.qsize(),
            "max_queue_size": self._max_queue_size,
            "workers_count": len(self._workers),
            "max_workers": self._max_workers,
            "processed_commands": self._processed_commands,
            "failed_commands": self._failed_commands,
            "uptime_seconds": uptime,
        }

    def is_healthy(self) -> bool:
        """Check if the queue is healthy"""
        return (
            self._is_running
            and len(self._workers) == self._max_workers
            and all(not worker.done() for worker in self._workers)
        )


class TaskQueueManager:
    """Manager for the async task queue with lifecycle management"""

    _instance: Optional[AsyncTaskQueue] = None
    _initialized = False

    @classmethod
    async def get_instance(
        cls, max_workers: int = 3, max_queue_size: int = 100
    ) -> AsyncTaskQueue:
        """Get or create the task queue instance"""
        if cls._instance is None:
            cls._instance = AsyncTaskQueue(max_workers, max_queue_size)

        if not cls._initialized:
            await cls._instance.start()
            cls._initialized = True

        return cls._instance

    @classmethod
    async def shutdown(cls) -> None:
        """Shutdown the task queue instance"""
        if cls._instance and cls._initialized:
            await cls._instance.stop()
            cls._initialized = False
            cls._instance = None

    @classmethod
    def is_initialized(cls) -> bool:
        """Check if the task queue is initialized"""
        return cls._initialized and cls._instance is not None
