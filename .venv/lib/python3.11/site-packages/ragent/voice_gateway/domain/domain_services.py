"""
Domain services for Voice Package - Callback-based transcript processing
"""

import asyncio
import time
from abc import ABC, abstractmethod
from typing import Callable

from ragent.voice_gateway.config.constants import Messages, OpenAIConfig, SocketEvents
from ragent.voice_gateway.infrastructure.services import (
    AudioService,
    EventEmitterService,
    SessionService,
    WebSocketService,
)
from ragent.voice_gateway.interfaces.interfaces import IConfigService
from ragent.voice_gateway.utils.exceptions import (
    AudioProcessingError,
    AudioValidationError,
    SessionError,
    WebSocketConnectionError,
)


class IAudioManagementService(ABC):
    """Interface for audio management operations"""

    @abstractmethod
    def validate_and_accumulate(self, client_id: str, audio_data: str) -> None:
        """Validate and accumulate audio data"""
        pass

    @abstractmethod
    def commit_accumulated_audio(self, client_id: str) -> None:
        """Commit accumulated audio for processing"""
        pass

    @abstractmethod
    def is_audio_sufficient(self, client_id: str) -> bool:
        """Check if accumulated audio meets minimum requirements"""
        pass


class IConversationOrchestrator(ABC):
    """Interface for conversation orchestration"""

    @abstractmethod
    async def process_transcript(self, client_id: str, transcript: str) -> str:
        """Process transcript and return response text"""
        pass


class ITTSService(ABC):
    """Interface for Text-to-Speech service"""

    @abstractmethod
    def create_voice_response(
        self, client_id: str, transcript: str, response_text: str
    ) -> None:
        """Create and send voice response to client"""
        pass


class AudioManagementService(IAudioManagementService):
    """Handles all audio-related operations"""

    def __init__(
        self,
        audio_service: AudioService,
        session_service: SessionService,
        websocket_service: WebSocketService,
        config_service: IConfigService,
    ):
        self._audio_service = audio_service
        self._session_service = session_service
        self._websocket_service = websocket_service
        self._config_service = config_service

    def validate_and_accumulate(self, client_id: str, audio_data: str) -> None:
        """Validate and accumulate audio data"""
        if not self._session_service.is_session_active(client_id):
            raise SessionError(f"No active session for client: {client_id}", client_id)

        validation_result = self._audio_service.validate_audio_format(audio_data)
        if not validation_result["valid"]:
            raise AudioValidationError(
                f"Invalid audio: {validation_result['reason']}", validation_result
            )

        self._audio_service.accumulate_audio(client_id, audio_data)
        self._send_audio_to_openai(client_id, audio_data)

    def commit_accumulated_audio(self, client_id: str) -> None:
        """Commit accumulated audio"""
        if not self._session_service.is_session_active(client_id):
            raise SessionError(f"No active session for client: {client_id}", client_id)

        if not self._audio_service.is_audio_sufficient(client_id):
            total_duration = self._audio_service.get_total_duration(client_id)
            constraints = self._config_service.get_audio_constraints()
            min_duration = constraints["min_duration_ms"]

            raise AudioProcessingError(
                f"Audio too short: {total_duration:.1f}ms (need â‰¥{min_duration}ms)",
                client_id,
                total_duration,
            )

        self._send_commit_to_openai(client_id)
        self._audio_service.clear_audio_buffer(client_id)

    def is_audio_sufficient(self, client_id: str) -> bool:
        """Check if accumulated audio meets minimum requirements"""
        return self._audio_service.is_audio_sufficient(client_id)

    def _send_audio_to_openai(self, client_id: str, audio_data: str) -> None:
        """Send audio data to OpenAI"""
        if not self._websocket_service.is_connected(client_id):
            raise WebSocketConnectionError(
                f"No OpenAI connection for client: {client_id}", client_id
            )

        audio_message = {
            "type": "input_audio_buffer.append",
            "audio": audio_data,
        }

        if not self._websocket_service.send_message(client_id, audio_message):
            raise WebSocketConnectionError("Failed to send audio to OpenAI", client_id)

    def _send_commit_to_openai(self, client_id: str) -> None:
        """Send commit command to OpenAI"""
        if not self._websocket_service.is_connected(client_id):
            raise WebSocketConnectionError(
                f"No OpenAI connection for client: {client_id}", client_id
            )

        commit_message = {"type": "input_audio_buffer.commit"}

        if not self._websocket_service.send_message(client_id, commit_message):
            raise WebSocketConnectionError(
                "Failed to commit audio to OpenAI", client_id
            )


class ConversationOrchestrator(IConversationOrchestrator):
    """Orchestrates conversation flow with callback-based agent integration"""

    def __init__(
        self,
        session_service: SessionService,
        event_emitter: EventEmitterService,
        tts_service: ITTSService,
        on_transcript_callback: Callable,
        callback_timeout: int = 120,
    ):
        self._session_service = session_service
        self._event_emitter = event_emitter
        self._tts_service = tts_service
        self._on_transcript_callback = on_transcript_callback
        self._callback_timeout = callback_timeout

    async def process_transcript(self, client_id: str, transcript: str) -> str:
        """Process transcript with callback - callback calls TTS directly"""

        try:
            session = self._session_service.get_session(client_id)
            if not session:
                raise SessionError(
                    f"No session found for client: {client_id}", client_id
                )

            chat_payload = session.get("chat_payload", {})

            # Create event emitter wrapper for callback
            event_emitter_wrapper = EventEmitterWrapper(self._event_emitter, client_id)

            # Create TTS wrapper for callback - project decides which field to use
            tts_wrapper = TTSWrapper(self._tts_service, client_id, transcript)

            # Call user-provided callback
            try:
                # Handle both async and sync callbacks
                if asyncio.iscoroutinefunction(self._on_transcript_callback):
                    callback_response = await asyncio.wait_for(
                        self._on_transcript_callback(
                            client_id,
                            transcript,
                            chat_payload,
                            event_emitter_wrapper,
                            tts_wrapper,
                        ),
                        timeout=self._callback_timeout,
                    )
                else:
                    # Run sync callback in thread pool
                    loop = asyncio.get_event_loop()
                    callback_response = await asyncio.wait_for(
                        loop.run_in_executor(
                            None,
                            lambda: self._on_transcript_callback(
                                client_id,
                                transcript,
                                chat_payload,
                                event_emitter_wrapper,
                                tts_wrapper,
                            ),
                        ),
                        timeout=self._callback_timeout,
                    )
            except asyncio.TimeoutError:
                raise TimeoutError(f"Callback timeout after {self._callback_timeout}s")
            except Exception:
                # Fallback: call TTS with error message
                tts_wrapper(f"Got your request: {transcript}")
                return f"Got your request: {transcript}"

            # Update session context if callback returned context updates
            if isinstance(callback_response, dict):
                self._update_session_context(client_id, callback_response, chat_payload)

            # Return success (TTS was already called by callback)
            return "processed"

        except Exception:
            # Fallback response
            return f"Got your request: {transcript}"

    def _update_session_context(
        self, client_id: str, callback_response: dict, current_chat_payload: dict
    ):
        """Update session with context from callback response"""
        session_updates = {}
        payload_updates = current_chat_payload.copy()

        # Update contextId if provided
        context_id = callback_response.get("contextId")
        if context_id:
            session_updates["context_id"] = context_id
            payload_updates["contextId"] = context_id

        # Update message_log if provided
        message_log = callback_response.get("message_log")
        if message_log is not None:
            session_updates["message_log"] = message_log
            if "metadata" in payload_updates:
                payload_updates["metadata"]["message_log"] = message_log

        # Update session
        if session_updates:
            session_updates["chat_payload"] = payload_updates
            self._session_service.update_session(client_id, session_updates)


class EventEmitterWrapper:
    """Wrapper for event emitter that provides simple emit() method for callbacks"""

    def __init__(self, event_emitter: EventEmitterService, client_id: str):
        self._event_emitter = event_emitter
        self._client_id = client_id

    def emit(self, event: str, data: dict) -> None:
        """Emit event to client (simplified interface for callbacks)"""
        self._event_emitter.emit_to_client(self._client_id, event, data)


class TTSWrapper:
    """Wrapper for TTS service that provides simple TTS() method for callbacks"""

    def __init__(self, tts_service: ITTSService, client_id: str, transcript: str):
        self._tts_service = tts_service
        self._client_id = client_id
        self._transcript = transcript

    def __call__(self, text: str) -> None:
        """Call TTS with text to speak (project decides which field to use)"""
        self._tts_service.create_voice_response(self._client_id, self._transcript, text)


class TTSService(ITTSService):
    """Handles Text-to-Speech response generation"""

    def __init__(
        self,
        websocket_service: WebSocketService,
        event_emitter: EventEmitterService,
    ):
        self._websocket_service = websocket_service
        self._event_emitter = event_emitter

    def create_voice_response(
        self, client_id: str, transcript: str, response_text: str
    ) -> None:
        """Create complete voice response (text + audio)"""
        try:
            # Send text response first
            self.send_text_response(client_id, transcript, response_text)

            # Generate TTS if WebSocket is connected
            if self._websocket_service.is_connected(client_id):
                self._generate_tts_response(client_id, response_text)
            else:
                self._event_emitter.emit_to_client(
                    client_id, SocketEvents.ERROR, {"message": Messages.TTS_UNAVAILABLE}
                )

        except Exception as e:
            self._event_emitter.emit_to_client(
                client_id,
                SocketEvents.ERROR,
                {"message": f"{Messages.TTS_ERROR}: {str(e)}"},
            )

    def send_text_response(
        self, client_id: str, transcript: str, response_text: str
    ) -> None:
        """Send text response to client"""
        response_data = {
            "transcript": transcript,
            "response": response_text,
            "timestamp": time.time(),
        }

        self._event_emitter.emit_to_client(
            client_id, SocketEvents.AI_RESPONSE, response_data
        )

    def _generate_tts_response(self, client_id: str, response_text: str) -> None:
        """Generate TTS response via OpenAI"""
        tts_text = f"{OpenAIConfig.TTS_PREFIX}{response_text}"

        conversation_item = {
            "type": "conversation.item.create",
            "item": {
                "id": f"msg_{int(time.time() * 1000)}",
                "type": "message",
                "role": "user",
                "content": [{"type": "input_text", "text": tts_text}],
            },
        }

        response_create = {
            "type": "response.create",
            "response": {
                "modalities": ["text", "audio"],
                "instructions": OpenAIConfig.TTS_INSTRUCTIONS,
                "tool_choice": "none",  # Always disable function calling for TTS
            },
        }

        self._websocket_service.send_message(client_id, conversation_item)
        self._websocket_service.send_message(client_id, response_create)


class DomainServiceFactory:
    """Factory for creating domain services"""

    def __init__(
        self,
        audio_service: AudioService,
        session_service: SessionService,
        websocket_service: WebSocketService,
        event_emitter: EventEmitterService,
        config_service: IConfigService,
        on_transcript_callback: Callable,
        callback_timeout: int = 120,
    ):
        self._audio_service = audio_service
        self._session_service = session_service
        self._websocket_service = websocket_service
        self._event_emitter = event_emitter
        self._config_service = config_service
        self._on_transcript_callback = on_transcript_callback
        self._callback_timeout = callback_timeout

    def create_audio_management_service(self) -> IAudioManagementService:
        """Create audio management service"""
        return AudioManagementService(
            self._audio_service,
            self._session_service,
            self._websocket_service,
            self._config_service,
        )

    def create_conversation_orchestrator(self) -> IConversationOrchestrator:
        """Create conversation orchestrator"""
        tts_service = self.create_tts_service()
        return ConversationOrchestrator(
            self._session_service,
            self._event_emitter,
            tts_service,
            self._on_transcript_callback,
            self._callback_timeout,
        )

    def create_tts_service(self) -> ITTSService:
        """Create TTS service"""
        return TTSService(self._websocket_service, self._event_emitter)
