import base64
import logging
import threading
import time
from typing import Any, Callable, Dict, Optional

from ragent.voice_gateway.config.constants import SessionStatus
from ragent.voice_gateway.infrastructure.universal_socketio import (
    UniversalSocketIOHandler,
    create_universal_handler,
)
from ragent.voice_gateway.infrastructure.websocket_client import RealtimeWebSocketClient
from ragent.voice_gateway.interfaces.interfaces import (
    IAudioService,
    IConfigService,
    IEventEmitter,
    ISessionService,
    IWebSocketService,
)

logger = logging.getLogger(__name__)


class AudioService(IAudioService):
    """Service for handling audio processing and validation"""

    def __init__(self, config_service: IConfigService):
        self.config = config_service
        self.audio_constraints = config_service.get_audio_constraints()
        self._client_audio_buffers: Dict[str, Dict[str, Any]] = {}

    def validate_audio_format(self, audio_data: str) -> Dict[str, Any]:
        """Validate audio format according to OpenAI requirements"""
        try:
            if not audio_data:
                return {"valid": False, "reason": "Empty audio data"}

            # Check if it's valid base64
            try:
                decoded = base64.b64decode(audio_data)
            except Exception:
                return {"valid": False, "reason": "Invalid base64 encoding"}

            # Check size constraints
            if len(decoded) < self.audio_constraints["min_size_bytes"]:
                return {"valid": False, "reason": "Audio data too small"}

            if len(decoded) > self.audio_constraints["max_size_bytes"]:
                return {"valid": False, "reason": "Audio data too large"}

            return {"valid": True, "info": f"Audio data: {len(decoded)} bytes"}

        except Exception as e:
            return {"valid": False, "reason": f"Validation error: {str(e)}"}

    def calculate_audio_duration(self, audio_data: str) -> float:
        """Calculate audio duration in milliseconds for PCM16 24kHz mono"""
        try:
            decoded_audio = base64.b64decode(audio_data)
            audio_bytes = len(decoded_audio)

            # PCM16 = 2 bytes per sample, 24kHz = 24000 samples per second
            sample_rate = self.audio_constraints["sample_rate"]
            bytes_per_sample = self.audio_constraints["bytes_per_sample"]

            duration_ms = (audio_bytes / bytes_per_sample) / sample_rate * 1000
            return duration_ms

        except Exception:
            return 0.0

    def accumulate_audio(self, client_id: str, audio_data: str) -> None:
        """Accumulate audio data for a client"""
        if client_id not in self._client_audio_buffers:
            self._client_audio_buffers[client_id] = {
                "chunks": [],
                "total_bytes": 0,
                "total_duration_ms": 0.0,
            }

        try:
            decoded_audio = base64.b64decode(audio_data)
            audio_bytes = len(decoded_audio)
            duration_ms = self.calculate_audio_duration(audio_data)

            buffer = self._client_audio_buffers[client_id]
            buffer["chunks"].append(audio_data)
            buffer["total_bytes"] += audio_bytes
            buffer["total_duration_ms"] += duration_ms

        except Exception:
            pass

    def get_total_duration(self, client_id: str) -> float:
        """Get total accumulated audio duration for a client"""
        if client_id not in self._client_audio_buffers:
            return 0.0
        return self._client_audio_buffers[client_id]["total_duration_ms"]

    def clear_audio_buffer(self, client_id: str) -> None:
        """Clear audio buffer for a client"""
        if client_id in self._client_audio_buffers:
            del self._client_audio_buffers[client_id]

    def is_audio_sufficient(self, client_id: str) -> bool:
        """Check if accumulated audio meets minimum duration requirements"""
        total_duration = self.get_total_duration(client_id)
        min_duration = self.audio_constraints["min_duration_ms"]
        return total_duration >= min_duration


class SessionService(ISessionService):
    """Service for managing voice sessions"""

    def __init__(self):
        self._sessions: Dict[str, Dict[str, Any]] = {}
        self._lock = threading.Lock()

    def create_session(
        self, client_id: str, chat_payload: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create a new session for a client"""
        with self._lock:
            session_data = {
                "status": "initializing",
                "created_at": time.time(),
                "chat_payload": chat_payload,
                "context_id": chat_payload.get("contextId"),
                "openai_connection": None,
            }

            self._sessions[client_id] = session_data

            return {"status": SessionStatus.CREATED, "session_id": client_id}

    def get_session(self, client_id: str) -> Optional[Dict[str, Any]]:
        """Get session for a client"""
        with self._lock:
            return self._sessions.get(client_id)

    def update_session(self, client_id: str, data: Dict[str, Any]) -> None:
        """Update session data for a client"""
        with self._lock:
            if client_id in self._sessions:
                self._sessions[client_id].update(data)

    def end_session(self, client_id: str) -> Dict[str, Any]:
        """End session for a client"""
        with self._lock:
            if client_id in self._sessions:
                session = self._sessions[client_id]

                # Close OpenAI connection if exists
                if session.get("openai_connection"):
                    try:
                        session["openai_connection"].close()
                    except Exception:
                        pass

                del self._sessions[client_id]
                return {"status": SessionStatus.ENDED}

            return {"status": "session_not_found"}

    def is_session_active(self, client_id: str) -> bool:
        """Check if session is active for a client"""
        with self._lock:
            session = self._sessions.get(client_id)
            active = session is not None and session.get("status") in [
                "initializing",
                "connected",
                "ready",
            ]
            return active


class WebSocketService(IWebSocketService):
    """Service for managing WebSocket connections to OpenAI"""

    def __init__(self, config_service: IConfigService):
        self.config = config_service
        self.openai_config = config_service.get_openai_config()
        self._connections: Dict[str, RealtimeWebSocketClient] = {}

    def connect(
        self,
        client_id: str,
        on_message: Callable,
        on_error: Callable,
        on_close: Callable,
    ) -> bool:
        """Connect to OpenAI WebSocket for a client"""
        try:
            voice_settings = self.config.get_runtime_voice_settings()
            instructions_info = ""
            if "instructions_length" in voice_settings:
                instructions_info = (
                    f" | instructions_length={voice_settings['instructions_length']}"
                )
            logger.info(
                "[%s] Starting OpenAI realtime session | model=%s | voice=%s | "
                "turn_detection=%s | transcription=%s | noise_reduction=%s | max_tokens=%s%s",
                client_id,
                voice_settings["voice_model"],
                voice_settings["voice"],
                voice_settings["turn_detection_mode"],
                voice_settings["transcription_model"],
                voice_settings["noise_reduction_mode"],
                voice_settings["max_output_tokens"],
                instructions_info,
            )

            ws_client = RealtimeWebSocketClient(
                url=self.openai_config["websocket_url"],
                headers=self.openai_config["headers"],
                on_message_callback=on_message,
                on_error_callback=on_error,
                on_close_callback=on_close,
            ).connect()

            self._connections[client_id] = ws_client

            # Send session configuration
            session_config_json = self.config.get_session_config_json()
            # Log instructions being used (parse from session config)
            import json

            try:
                session_config = json.loads(session_config_json)
                instructions = session_config.get("session", {}).get("instructions", "")
                if instructions:
                    logger.info(
                        "[%s] Sending session.update with instructions (length: %d chars, preview: %s)",
                        client_id,
                        len(instructions),
                        instructions[:100] + "..."
                        if len(instructions) > 100
                        else instructions,
                    )
            except Exception:
                pass  # Don't fail if parsing fails
            ws_client.send(session_config_json)

            return True

        except Exception as e:
            logger.error(
                "[%s] Failed to establish OpenAI realtime session: %s",
                client_id,
                str(e),
                exc_info=True,
            )
            return False

    def send_message(self, client_id: str, message: Dict[str, Any]) -> bool:
        """Send message to OpenAI WebSocket"""
        try:
            if client_id in self._connections:
                self._connections[client_id].send(message)
                return True
            else:
                return False

        except Exception:
            return False

    def disconnect(self, client_id: str) -> None:
        """Disconnect WebSocket for a client"""
        if client_id in self._connections:
            try:
                self._connections[client_id].close()
                del self._connections[client_id]
            except Exception:
                pass

    def is_connected(self, client_id: str) -> bool:
        """Check if WebSocket is connected for a client"""
        connected = (
            client_id in self._connections
            and self._connections[client_id].is_connected()
        )
        return connected


class EventEmitterService(IEventEmitter):
    """
    Service for emitting events to clients.

    Supports both:
    - Direct Socket.IO instances (Flask-SocketIO, python-socketio)
    - UniversalSocketIOHandler (auto-detects sync/async)
    """

    def __init__(self, socketio_instance=None):
        """
        Initialize the event emitter.

        Args:
            socketio_instance: Either a Socket.IO instance or UniversalSocketIOHandler
        """
        # Auto-wrap with UniversalSocketIOHandler if not already wrapped
        if socketio_instance and not isinstance(
            socketio_instance, UniversalSocketIOHandler
        ):
            self.socketio = create_universal_handler(socketio_instance)
        else:
            self.socketio = socketio_instance

    def set_socketio_instance(self, socketio_instance):
        """
        Set the SocketIO instance for event emission.

        Args:
            socketio_instance: Either a Socket.IO instance or UniversalSocketIOHandler
        """
        # Auto-wrap with UniversalSocketIOHandler if not already wrapped
        if socketio_instance and not isinstance(
            socketio_instance, UniversalSocketIOHandler
        ):
            self.socketio = create_universal_handler(socketio_instance)
        else:
            self.socketio = socketio_instance

    def emit_to_client(self, client_id: str, event: str, data: Dict[str, Any]) -> None:
        """
        Emit event to specific client.

        Works with both sync (Flask-SocketIO) and async (python-socketio) automatically.
        """
        try:
            if self.socketio:
                self.socketio.emit(event, data, to=client_id)
        except Exception:
            pass

    def emit(self, event: str, data: Dict[str, Any], client_id: str = None) -> None:
        """
        Emit event (generic method for callback usage).

        Works with both sync (Flask-SocketIO) and async (python-socketio) automatically.
        """
        if client_id:
            self.emit_to_client(client_id, event, data)
        else:
            # If no client_id, emit to all (for broadcast events)
            try:
                if self.socketio:
                    self.socketio.emit(event, data)
            except Exception:
                pass
