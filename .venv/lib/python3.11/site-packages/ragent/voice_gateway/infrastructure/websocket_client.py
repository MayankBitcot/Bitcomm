import json
import threading
import time

import websocket


class RealtimeWebSocketClient:
    """
    WebSocket client for OpenAI Realtime API
    """

    def __init__(
        self,
        url,
        headers,
        on_message_callback,
        on_error_callback=None,
        on_close_callback=None,
    ):
        self.url = url
        self.headers = headers
        self.on_message_callback = on_message_callback
        self.on_error_callback = on_error_callback
        self.on_close_callback = on_close_callback
        self.ws = None
        self.is_open = False
        self.receive_thread = None

    def on_open(self, ws=None):
        """Handle WebSocket connection open"""
        self.is_open = True

    def on_message(self, ws, message=None):
        """Handle incoming WebSocket messages"""
        if message is None and isinstance(ws, str):
            message = ws

        if not message:
            return

        try:
            # Check for error messages from OpenAI
            msg_data = json.loads(message)
            if msg_data.get("type") == "error":
                error_msg = msg_data.get("error", {}).get("message", "Unknown error")
                if self.on_error_callback:
                    self.on_error_callback(Exception(error_msg))
        except json.JSONDecodeError:
            pass

        try:
            if self.on_message_callback:
                self.on_message_callback(message)
        except Exception as e:
            if self.on_error_callback:
                self.on_error_callback(e)

    def on_error(self, ws, error=None):
        """Handle WebSocket errors"""
        if error is None and isinstance(ws, Exception):
            error = ws

        if self.on_error_callback:
            self.on_error_callback(
                error if error else Exception("Unknown WebSocket error")
            )

    def on_close(self, ws, *args):
        """Handle WebSocket connection closure"""
        self.is_open = False
        if self.on_close_callback:
            self.on_close_callback()

    def connect(self):
        """Connect to the WebSocket server"""
        websocket.enableTrace(False)

        self.ws = websocket.WebSocketApp(
            self.url,
            header=self.headers,
            on_open=self.on_open,
            on_message=self.on_message,
            on_error=self.on_error,
            on_close=self.on_close,
        )

        # Start WebSocket connection in a background thread
        self.receive_thread = threading.Thread(target=self._run_with_retry)
        self.receive_thread.daemon = True
        self.receive_thread.start()

        # Wait for connection to establish
        timeout = 10
        start = time.time()
        while not self.is_open and time.time() - start < timeout:
            time.sleep(0.1)

        if not self.is_open:
            raise ConnectionError(
                "Failed to establish WebSocket connection within timeout"
            )

        return self

    def _run_with_retry(self):
        """Run the WebSocket connection"""
        try:
            if self.ws:
                self.ws.run_forever(ping_interval=20, ping_timeout=10)
        except Exception as e:
            if self.on_error_callback:
                self.on_error_callback(e)

        self.is_open = False

    def send(self, data):
        """Send data through the WebSocket connection"""
        if not self.is_open or not self.ws:
            raise ConnectionError("WebSocket connection is not open")

        if isinstance(data, dict):
            data = json.dumps(data)

        self.ws.send(data)

    def close(self):
        """Close the WebSocket connection"""
        if self.ws and self.is_open:
            self.ws.close()
            self.is_open = False

    def is_connected(self):
        """Check if the WebSocket connection is open and active"""
        return self.is_open and self.ws is not None
