"""
Text splitter implementations for document chunking.
"""
from typing import Any, Dict, List, Type, Union

from langchain_classic.text_splitter import RecursiveCharacterTextSplitter, TextSplitter

from ragent.log_utils import logger


class InvalidSplitterType(Exception):
    """Custom exception for invalid splitter types."""

    pass


# Registry of available splitters
SPLITTER_REGISTRY: Dict[str, Type[TextSplitter]] = {
    "recursive": RecursiveCharacterTextSplitter,
    # Add more splitters as needed
}


def get_splitter_class(splitter_type: str) -> Type[TextSplitter]:
    """
    Get the splitter class based on the splitter type.

    Args:
        splitter_type: Type of splitter to use

    Returns:
        TextSplitter subclass

    Raises:
        InvalidSplitterType: If the splitter type is not supported
    """
    splitter_class = SPLITTER_REGISTRY.get(splitter_type.lower())
    if not splitter_class:
        raise InvalidSplitterType(f"Splitter type '{splitter_type}' is not supported")
    return splitter_class


def register_splitter(splitter_type: str, splitter_class: Type[TextSplitter]) -> None:
    """
    Register a new splitter.

    Args:
        splitter_type: Splitter type identifier (e.g., 'recursive', 'token')
        splitter_class: The splitter class to register
    """
    SPLITTER_REGISTRY[splitter_type.lower()] = splitter_class


def is_splitter_instance(obj: Any) -> bool:
    """
    Check if an object is a splitter instance.

    Args:
        obj: Object to check

    Returns:
        bool: True if obj is a splitter instance, False otherwise
    """
    return (
        obj is not None
        and hasattr(obj, "split_documents")
        and callable(obj.split_documents)
    )


def split_documents(
    documents: List,
    chunk_size: int,
    chunk_overlap: int,
    splitter: Union[str, dict, TextSplitter, None] = "recursive",
    splitter_params: Dict[str, Any] = None,
) -> List:
    """
    Splits documents into smaller chunks for better processing.

    Args:
        documents: List of documents to split
        splitter: Can be one of the following:
                 - A splitter name (str)
                 - A dictionary with format {splitter_name: SplitterClass}
                 - A splitter instance (TextSplitter)
                 Default is "recursive" if None is provided
        chunk_size: Maximum size of each chunk
        chunk_overlap: Number of characters to overlap between chunks
        splitter_params: Additional parameters to pass to the splitter

    Returns:
        List of split documents

    Raises:
        InvalidSplitterType: If the splitter type is not supported
    """
    if splitter_params is None:
        splitter_params = {}

    try:
        # Case 1: If a splitter instance is provided, use it directly
        if is_splitter_instance(splitter):
            splitter_instance = splitter

        # Case 2: If a dictionary is provided in format {splitter_name: SplitterClass}
        elif isinstance(splitter, dict) and len(splitter) == 1:
            splitter_name, splitter_class = next(iter(splitter.items()))
            logger.info(
                f"Using splitter from dictionary: {splitter_name} with class {splitter_class}"
            )

            # Check if the class is a valid splitter class
            if not issubclass(splitter_class, TextSplitter):
                raise InvalidSplitterType(
                    f"""
                    The class provided in the dictionary must be a TextSplitter subclass, got
                    {splitter_class}
                    """
                )

            # Configure parameters
            params = {"chunk_size": chunk_size, "chunk_overlap": chunk_overlap}

            # Add any additional parameters
            params.update(splitter_params or {})

            # Instantiate the splitter
            splitter_instance = splitter_class(**params)

            # Optionally register this splitter for future use
            if splitter_name not in SPLITTER_REGISTRY:
                register_splitter(splitter_name, splitter_class)

        # Case 3: If a splitter name (string) is provided or using default,
        # get the class and instantiate it
        elif isinstance(splitter, str) or splitter is None:
            logger.info(f"Using splitter name: {splitter}")
            splitter_type = splitter or "recursive"

            splitter_class = get_splitter_class(splitter_type)
            logger.info(f"Using splitter class {splitter_class}")

            # Configure base parameters
            params = {"chunk_size": chunk_size, "chunk_overlap": chunk_overlap}

            # Add any additional parameters
            params.update(splitter_params)

            # Instantiate the splitter
            splitter_instance = splitter_class(**params)

        else:
            # Invalid type
            raise InvalidSplitterType(
                f"""Splitter must be a string name, dictionary with format {{name: class}},
                or TextSplitter instance, got {type(splitter)}"""
            )

        # Split the documents
        split_docs = splitter_instance.split_documents(documents)

        return split_docs

    except InvalidSplitterType as e:
        error_message = f"Invalid splitter type: {e}"
        raise InvalidSplitterType(error_message)

    except Exception as e:
        error_message = f"Error splitting documents: {e}"
        raise ValueError(error_message)
