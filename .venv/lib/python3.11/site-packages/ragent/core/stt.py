import base64
import os
from abc import ABC, abstractmethod
from pathlib import Path

from ragent.log_utils import logger


class SpeechToTextError(Exception):
    """Custom exception for SpeechToText errors."""

    pass


class BaseSpeechToText(ABC):
    def process_speech(self, base64_audio: str, *kwargs) -> str:
        """Convert base64 audio to speech and return audio bytes."""
        if not base64_audio:
            raise ValueError("Input base64 audio data cannot be empty.")

        temp_audio_path = None
        try:
            # Decode the base64 audio data
            audio_data = base64.b64decode(base64_audio)
            # Save the decoded data to a temporary audio file
            temp_audio_path = (
                Path("/tmp")
                / f"temp_audio_stt_{os.getpid()}_{os.urandom(8).hex()}.webm"
            )
            with open(temp_audio_path, "wb") as audio_file:
                audio_file.write(audio_data)
            logger.info(f"Temporary audio file saved at: {temp_audio_path}")
            return self._speech_to_text(temp_audio_path, *kwargs)
        except OSError as e:
            # More specific exception for file-related errors (saving the audio file)
            logger.error(f"Error saving temporary audio file: {e}", exc_info=True)
            raise SpeechToTextError(f"Failed to save audio file: {e}") from e
        except Exception as e:
            # Generic exception for all other unforeseen errors
            logger.error(
                f"An unexpected error occurred during speech processing: {e}",
                exc_info=True,
            )
            raise SpeechToTextError(f"An unexpected error occurred: {e}") from e
        finally:
            # Clean up the temporary file, ensuring it exists before trying to delete
            if temp_audio_path and temp_audio_path.exists():
                try:
                    temp_audio_path.unlink()
                    logger.info(f"Cleaned up temporary file: {temp_audio_path}")
                except OSError as e:
                    # Handle file cleanup errors more specifically
                    logger.warning(
                        f"Failed to clean up temporary file {temp_audio_path}: {e}",
                        exc_info=True,
                    )

    @abstractmethod
    def _speech_to_text(
        self, path: str, stt_prompt: str = None, model_name: str = "default_model"
    ) -> str:
        """Process the audio file and return the transcribed text."""
        pass
